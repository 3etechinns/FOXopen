<?xml version="1.0" encoding="UTF-8"?>
<xs:schema targetNamespace="http://www.og.dti.gov/fox_module" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:fm="http://www.og.dti.gov/fox_module" xmlns:error="http://www.og.dti.gov/fox_global" xmlns:foxg="http://www.og.dti.gov/fox_global" xmlns:fox="http://www.og.dti.gov/fox" elementFormDefault="qualified" attributeFormDefault="unqualified" version="$Header$">
  <xs:include schemaLocation="fox_common_types.xsd"/>
  <xs:import schemaLocation="fox_import.xsd"/>
  <xs:import namespace="http://www.og.dti.gov/fox" schemaLocation="fox.xsd"/>
  <xs:element name="module">
    <xs:annotation>
      <xs:documentation>Container for the definition of a FOX module.</xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:sequence>
        <xs:element name="header">
          <xs:complexType>
            <xs:sequence>
              <xs:element name="name" type="fm:entered-string"/>
              <xs:element name="title" type="fm:entered-string"/>
              <xs:element name="application-title" type="fm:entered-string"/>
              <xs:element name="documentation" minOccurs="0">
                <xs:complexType>
                  <xs:complexContent>
                    <xs:extension base="fm:documentation">
                      <xs:sequence>
                        <xs:element name="name-space-list">
                          <xs:annotation>
                            <xs:documentation>List of name spaces and their usage</xs:documentation>
                          </xs:annotation>
                          <xs:complexType>
                            <xs:sequence>
                              <xs:element name="name-space" minOccurs="0" maxOccurs="unbounded">
                                <xs:complexType>
                                  <xs:sequence>
                                    <xs:element name="name" nillable="false"/>
                                    <xs:element name="description"/>
                                    <xs:element name="comments"/>
                                  </xs:sequence>
                                </xs:complexType>
                              </xs:element>
                            </xs:sequence>
                          </xs:complexType>
                        </xs:element>
                      </xs:sequence>
                    </xs:extension>
                  </xs:complexContent>
                </xs:complexType>
              </xs:element>
              <xs:element name="version-no">
                <xs:simpleType>
                  <xs:restriction base="fm:entered-string">
                    <xs:pattern value="[$]Id(: .*)?[$]"/>
                  </xs:restriction>
                </xs:simpleType>
              </xs:element>
              <xs:element name="version-desc" minOccurs="0">
                <xs:simpleType>
                  <xs:restriction base="xs:string">
                    <xs:pattern value="([$]Header(: .*)?[$])?"/>
                  </xs:restriction>
                </xs:simpleType>
              </xs:element>
              <xs:element name="description" type="xs:string" minOccurs="0"/>
              <xs:element name="build-notes" type="xs:string" minOccurs="0"/>
              <xs:element name="help-text" type="xs:string" minOccurs="0"/>
            </xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name="control">
          <xs:complexType>
            <xs:sequence>
              <xs:element name="transaction-mode" minOccurs="0">
                <xs:simpleType>
                  <xs:restriction base="fm:entered-string">
                    <xs:enumeration value="read-committed"/>
                    <xs:enumeration value="write-uncommitted"/>
                  </xs:restriction>
                </xs:simpleType>
              </xs:element>
              <xs:element name="authentication" minOccurs="0">
                <xs:simpleType>
                  <xs:restriction base="fm:entered-string">
                    <xs:enumeration value="required"/>
                    <xs:enumeration value="not-required"/>
                  </xs:restriction>
                </xs:simpleType>
              </xs:element>
              <xs:element minOccurs="0" name="assertion-module">
                <xs:annotation>
                  <xs:documentation>The existence of this element marks the module as an assertion module which can be executed by the assertion runner. Child elements can be used to refine the behavior of the module when it is accessed as an assertion module.</xs:documentation>
                </xs:annotation>
                <xs:complexType>
                  <xs:sequence>
                    <xs:element minOccurs="0" name="entry-theme" type="xs:string">
                      <xs:annotation>
                        <xs:documentation>Specifies the entry theme which is used when the module is invoked by the assertion runner. If not specified, the module's default entry theme is used.</xs:documentation>
                      </xs:annotation>
                    </xs:element>
                    <xs:element minOccurs="0" name="before-action" type="xs:string">
                      <xs:annotation>
                        <xs:documentation>Defines an action which is run before each assertion action. This can be used to provide generic setup code for all assertion actions in the module. Errors in the before action will prevent the assertion action from running.</xs:documentation>
                      </xs:annotation>
                    </xs:element>
                    <xs:element minOccurs="0" name="after-action" type="xs:string">
                      <xs:annotation>
                        <xs:documentation>Defines an action which is run after each assertion action. This can be used to provide generic cleandown code for all assertion actions in the module. The after action is always run, even in the event of an error.</xs:documentation>
                      </xs:annotation>
                    </xs:element>
                    <xs:element minOccurs="0" name="test-categories" type="xs:string">
                      <xs:annotation>
                        <xs:documentation>A CSV list of test categories which the assertion module belongs to. This is used by the category endpoint to select assertion modules to run.</xs:documentation>
                      </xs:annotation>
                    </xs:element>
                  </xs:sequence>
                </xs:complexType>
              </xs:element>
              <xs:element name="transaction-mode-new" minOccurs="0">
                <xs:simpleType>
                  <xs:restriction base="fm:entered-string">
                    <xs:enumeration value="read-committed/write"/>
                    <xs:enumeration value="read-only-statement-consistent"/>
                    <xs:enumeration value="read-only-session-consistent"/>
                    <xs:enumeration value="serializable-read/write"/>
                    <xs:enumeration value="repeatable-read/write"/>
                    <xs:enumeration value="read-uncommitted/write"/>
                  </xs:restriction>
                </xs:simpleType>
              </xs:element>
              <xs:element name="transaction-commit" minOccurs="0">
                <xs:simpleType>
                  <xs:restriction base="fm:entered-string">
                    <xs:enumeration value="manual"/>
                    <xs:enumeration value="auto-action-end"/>
                  </xs:restriction>
                </xs:simpleType>
              </xs:element>
              <xs:element name="transaction-procedural-state" minOccurs="0">
                <xs:simpleType>
                  <xs:restriction base="fm:entered-string">
                    <xs:enumeration value="unimportant-auto-clear-action-end"/>
                    <xs:enumeration value="important-replay-to-restore"/>
                    <xs:enumeration value="important-failure-final"/>
                  </xs:restriction>
                </xs:simpleType>
              </xs:element>
              <xs:element name="xml-commit" minOccurs="0">
                <xs:simpleType>
                  <xs:restriction base="fm:entered-string">
                    <xs:enumeration value="auto-autonomous-action-end"/>
                    <xs:enumeration value="ZZtransactional"/>
                    <xs:enumeration value="with-transaction"/>
                    <xs:enumeration value="ZZautonomous-lock-transaction-commit"/>
                    <xs:enumeration value="ZZautonomous-lock-commit"/>
                    <xs:enumeration value="ZZtransaction-lock-commit"/>
                  </xs:restriction>
                </xs:simpleType>
              </xs:element>
            </xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name="namespace-group-list" minOccurs="0" maxOccurs="1">
          <xs:complexType>
            <xs:sequence>
              <xs:element name="namespace-group" minOccurs="0" maxOccurs="unbounded">
                <xs:annotation>
                  <xs:documentation>
                    A namespace group allows you to group together a series of namespaces as part of a common concept for re-use in one or more security rules.
                    Examples could include: namespaces that should be editable when a case is open, but viewable at any other time, actions that can be used when a case is open, actions that should be used when viewing, but not editing, and so on.
                    A namespace group may extend an another namespace group using the "extends" attribute.
                  </xs:documentation>
                </xs:annotation>
                <xs:complexType>
                  <xs:sequence>
                    <xs:element name="namespace" type="fm:entered-string" minOccurs="1" maxOccurs="unbounded">
                      <xs:annotation>
                        <xs:documentation>
                          A namespace that should be included in this group. Must be a valid namespace, declared on the xs:schema element.
                        </xs:documentation>
                      </xs:annotation>
                    </xs:element>
                  </xs:sequence>
                  <xs:attribute name="name" type="xs:string" use="required">
                    <xs:annotation>
                      <xs:documentation>
                        Each group must be named so that it can be referred to by name in a fm:mode-rule or fm:view-rule.
                      </xs:documentation>
                    </xs:annotation>
                  </xs:attribute>
                  <xs:attribute name="extends" type="xs:string" use="optional">
                    <xs:annotation>
                      <xs:documentation>
                        A namespace group may optionally extend another namespace group. The "extends" attribute is followed until a group without an "extends" attribute is found. The resulting group will contain all namespaces from the entire chain.
                      </xs:documentation>
                    </xs:annotation>
                  </xs:attribute>
                </xs:complexType>
              </xs:element>
            </xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name="security-list">
          <xs:complexType>
            <xs:sequence>
              <xs:element name="security-rule" minOccurs="0" maxOccurs="unbounded">
                <xs:complexType>
                  <xs:attribute name="name" type="xs:string" use="required"/>
                  <xs:attributeGroup ref="fm:security-rule-conditions-att-grp"/>
                </xs:complexType>
              </xs:element>
              <xs:element name="mode-rule" minOccurs="0" maxOccurs="unbounded">
                <xs:complexType>
                  <xs:attributeGroup ref="fm:security-rule-ref-att-grp"/>
                  <xs:attributeGroup ref="fm:security-rule-op-att-grp"/>
                  <xs:attributeGroup ref="fm:security-rule-conditions-att-grp"/>
                </xs:complexType>
              </xs:element>
              <xs:element name="view-rule" minOccurs="0" maxOccurs="unbounded">
                <xs:complexType>
                  <xs:attributeGroup ref="fm:security-rule-ref-att-grp"/>
                  <xs:attributeGroup ref="fm:security-rule-op-att-grp"/>
                  <xs:attributeGroup ref="fm:security-rule-conditions-att-grp"/>
                </xs:complexType>
              </xs:element>
            </xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name="library-list">
          <xs:complexType>
            <xs:sequence>
              <xs:element name="schema" type="fm:entered-string" minOccurs="0">
                <xs:annotation>
                  <xs:documentation>Primary data schema definition fox component in
                    format:[Application/]ComponentPath where [Application is optional] A module can
                    reference itself a the schema.</xs:documentation>
                </xs:annotation>
              </xs:element>
              <xs:element name="library" minOccurs="0" maxOccurs="unbounded">
                <xs:annotation>
                  <xs:documentation>Fox component reference in format: [Application/]ComponentPath
                    where [Application is optional] </xs:documentation>
                </xs:annotation>
                <xs:simpleType>
                  <xs:restriction base="fm:entered-string">
                    <xs:minLength value="1"/>
                  </xs:restriction>
                </xs:simpleType>
              </xs:element>
            </xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name="xpath-list" minOccurs="0" type="fm:xpath-list-type">
          <xs:unique name="unique-xpath-name-within-module">
            <xs:selector xpath="./fm:xpath"/>
            <xs:field xpath="@name"/>
          </xs:unique>
        </xs:element>
        <xs:element name="storage-location-list">
          <xs:complexType>
            <xs:sequence>
              <xs:element name="storage-location" minOccurs="0" maxOccurs="unbounded">
                <xs:complexType>
                  <xs:complexContent>
                    <xs:extension base="fm:storage-location-type">
                      <xs:attribute name="name" type="fm:entered-string" use="required"/>
                      <xs:attribute name="xml-storage-type" use="optional">
                        <xs:annotation>
                          <xs:documentation>The underlying Oracle XML storage type of this storage location. It is important to enter this correctly. Entering an incorrect value can cause performance problems. The default is 'clob'.</xs:documentation>
                        </xs:annotation>
                        <xs:simpleType>
                          <xs:restriction base="fm:entered-string">
                            <xs:enumeration value="binary"/>
                            <xs:enumeration value="clob"/>
                          </xs:restriction>
                        </xs:simpleType>
                      </xs:attribute>
                      <xs:attribute name="stub-overload"/>
                      <xs:attribute name="build-only"/>
                    </xs:extension>
                  </xs:complexContent>
                </xs:complexType>
              </xs:element>
              <xs:element name="file-storage-location" minOccurs="0" maxOccurs="unbounded">
                <xs:complexType>
                  <xs:complexContent>
                    <xs:extension base="fm:file-storage-location-type">
                      <xs:attribute name="name" type="xs:string" use="required"/>
                      <xs:attribute name="is-upload-target" type="xs:boolean"/>
                      <xs:attribute name="stub-overload"/>
                      <xs:attribute name="build-only"/>
                    </xs:extension>
                  </xs:complexContent>
                </xs:complexType>
              </xs:element>
            </xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name="entry-theme-list">
          <xs:complexType>
            <xs:sequence>
              <xs:element name="entry-theme" minOccurs="0" maxOccurs="unbounded">
                <xs:complexType>
                  <xs:sequence>
                    <xs:choice>
                      <xs:element name="storage-location">
                        <xs:annotation>
                          <xs:documentation>Enter a name of a single storage location for this entry theme to use. This will be treated as the default storage location.</xs:documentation>
                        </xs:annotation>
                        <xs:complexType>
                          <xs:simpleContent>
                            <xs:extension base="fm:entered-string">
                              <xs:attributeGroup ref="fm:sl-option-attr-grp"/>
                            </xs:extension>
                          </xs:simpleContent>
                        </xs:complexType>
                      </xs:element>
                      <xs:element name="storage-location-list">
                        <xs:annotation>
                          <xs:documentation>Enter one or more storage location names which will be available to this entry theme. If you specify more than one you must ensure each has a context label defined and you must also define a default for attach point evaluation. If you only specify one storage location it will be considered the default.</xs:documentation>
                        </xs:annotation>
                        <xs:complexType>
                          <xs:sequence>
                            <xs:element name="storage-location" maxOccurs="unbounded">
                              <xs:complexType>
                                <xs:simpleContent>
                                  <xs:extension base="fm:entered-string">
                                    <xs:attribute name="default" type="xs:boolean" use="optional"/>
                                    <xs:attributeGroup ref="fm:sl-option-attr-grp"/>
                                  </xs:extension>
                                </xs:simpleContent>
                              </xs:complexType>
                            </xs:element>
                          </xs:sequence>
                          <xs:attributeGroup ref="fm:sl-option-attr-grp"/>
                        </xs:complexType>
                      </xs:element>
                    </xs:choice>
                    <xs:element name="state" type="fm:entered-string"/>
                    <xs:element name="attach" type="fm:fox-xpath-type">
                      <xs:annotation>
                        <xs:documentation>Enter an XPath to the initial attach point of this entry theme. The initial document of the XPath will be the document node of the default storage location. Therefore the XPath "/*" will evaluate to the root element of the default storage location.</xs:documentation>
                      </xs:annotation>
                    </xs:element>
                    <xs:element minOccurs="0" name="before-entry" type="fm:do-block-type"/>
                    <xs:element minOccurs="0" name="security">
                      <xs:annotation>
                        <xs:documentation>User privilege checking logic for this entry-theme.</xs:documentation>
                      </xs:annotation>
                      <xs:complexType>
                        <xs:sequence>
                          <xs:element minOccurs="0" name="before-validation" type="fm:do-block-type">
                            <xs:annotation>
                              <xs:documentation>Optional list of commands to run before performing security validation. These should be used to set up user privileges (i.e. security-scope, etc).</xs:documentation>
                            </xs:annotation>
                          </xs:element>
                          <xs:choice>
                            <xs:element name="privilege-list" type="fm:entered-string">
                              <xs:annotation>
                                <xs:documentation>A CSV list of privilege names. The user must have at least one to be allowed in to this entry theme.</xs:documentation>
                              </xs:annotation>
                            </xs:element>
                            <xs:element name="privilege-test">
                              <xs:annotation>
                                <xs:documentation>An XPath to run to determine if the user should be allowed in. This should return true to allow access or false to deny access.</xs:documentation>
                              </xs:annotation>
                              <xs:complexType>
                                <xs:attribute name="xpath"/>
                              </xs:complexType>
                            </xs:element>
                          </xs:choice>
                        </xs:sequence>
                      </xs:complexType>
                    </xs:element>
                    <xs:element name="do" type="fm:do-block-type"/>
                    <xs:element name="header-param-list" minOccurs="0">
                      <xs:complexType>
                        <xs:sequence>
                          <xs:element name="header-param" maxOccurs="unbounded">
                            <xs:complexType>
                              <xs:attributeGroup ref="fm:entry-theme-param-att-grp"/>
                            </xs:complexType>
                          </xs:element>
                        </xs:sequence>
                      </xs:complexType>
                    </xs:element>
                    <xs:element name="param-list" minOccurs="0">
                      <xs:complexType>
                        <xs:sequence>
                          <xs:element name="param" maxOccurs="unbounded">
                            <xs:complexType>
                              <xs:attributeGroup ref="fm:entry-theme-param-att-grp"/>
                            </xs:complexType>
                          </xs:element>
                        </xs:sequence>
                      </xs:complexType>
                    </xs:element>
                    <xs:element name="return-list" minOccurs="0">
                      <xs:complexType>
                        <xs:sequence>
                          <xs:element name="return" maxOccurs="unbounded">
                            <xs:complexType>
                              <xs:attributeGroup ref="fm:entry-theme-param-att-grp"/>
                            </xs:complexType>
                          </xs:element>
                        </xs:sequence>
                      </xs:complexType>
                    </xs:element>
                    <xs:element name="documentation" minOccurs="0">
                      <xs:complexType>
                        <xs:complexContent>
                          <xs:extension base="fm:documentation">
                            <xs:sequence>
                              <xs:element name="parameter-list" minOccurs="0" maxOccurs="0">
                                <xs:annotation>
                                  <xs:documentation>List of the parameters required for the entry
                                    theme. This element has been deprecated due to the introduction
                                    of fm:param-list and fm:return-list which have validated
                                    types.</xs:documentation>
                                </xs:annotation>
                                <xs:complexType>
                                  <xs:sequence>
                                    <xs:element name="parameter" minOccurs="0" maxOccurs="0">
                                      <xs:annotation>
                                        <xs:documentation>This element has been deprecated due to
                                          the introduction of fm:param-list and fm:return-list which
                                          have validated types.</xs:documentation>
                                      </xs:annotation>
                                      <xs:complexType>
                                        <xs:sequence>
                                          <xs:element name="name"/>
                                          <xs:element name="description"/>
                                          <xs:element name="data-type" minOccurs="0"/>
                                          <xs:element name="data-mapping" minOccurs="0"/>
                                        </xs:sequence>
                                      </xs:complexType>
                                    </xs:element>
                                  </xs:sequence>
                                </xs:complexType>
                              </xs:element>
                            </xs:sequence>
                          </xs:extension>
                        </xs:complexContent>
                      </xs:complexType>
                    </xs:element>
                  </xs:sequence>
                  <xs:attribute name="name" type="fm:entered-string" use="required"/>
                  <xs:attribute name="stub-overload"/>
                  <xs:attribute name="build-only"/>
                  <xs:attribute name="type" use="optional" default="internal">
                    <xs:simpleType>
                      <xs:restriction base="fm:entered-string">
                        <xs:enumeration value="internal"/>
                        <xs:enumeration value="external"/>
                        <xs:enumeration value="service-rpc"/>
                        <xs:enumeration value="service-document"/>
                      </xs:restriction>
                    </xs:simpleType>
                  </xs:attribute>
                  <xs:attribute name="persistent-thread" type="xs:boolean" use="optional" default="false"/>
                  <xs:attribute name="published" type="xs:boolean" use="optional" default="false"/>
                  <xs:attribute name="authentication-type" use="optional">
                    <xs:simpleType>
                      <xs:restriction base="fm:entered-string">
                        <xs:enumeration value="portal"/>
                        <xs:enumeration value="http"/>
                        <xs:enumeration value="saml"/>
                      </xs:restriction>
                    </xs:simpleType>
                  </xs:attribute>
                  <xs:attribute name="default" type="xs:boolean" use="optional" default="false"/>
                  <xs:attribute name="allow-expired-access" type="xs:boolean" use="optional" default="false">
                    <xs:annotation>
                      <xs:documentation>If true, this entry theme may be directly entered by a user with an expired password. Otherwise, if the user's password is expired, they will be redirected to the app's expired password module.</xs:documentation>
                    </xs:annotation>
                  </xs:attribute>
                </xs:complexType>
              </xs:element>
            </xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name="action-list" type="fm:action-list-type"/>
        <xs:element name="db-interface-list">
          <xs:annotation>
            <xs:documentation>Contains all interfaces for a module to describe how database selects,
              inserts updates, locks and native API calls are processed</xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence>
              <xs:group ref="fm:db-interface-grp"/>
            </xs:sequence>
          </xs:complexType>
          <xs:key name="db-interface-name-pkey">
            <xs:selector xpath="fm:db-interface"/>
            <xs:field xpath="@name"/>
          </xs:key>
        </xs:element>
        <xs:element name="css-list" minOccurs="0">
          <xs:complexType>
            <xs:sequence>
              <xs:element name="css" minOccurs="0" maxOccurs="unbounded">
                <xs:complexType mixed="true">
                  <xs:attribute name="type" use="optional">
                    <xs:simpleType>
                      <xs:restriction base="fm:entered-string">
                        <xs:enumeration value="accessible"/>
                        <xs:enumeration value="standard"/>
                        <xs:enumeration value="standard-and-accessible"/>
                        <xs:enumeration value="print"/>
                        <xs:enumeration value="pdf"/>
                      </xs:restriction>
                    </xs:simpleType>
                  </xs:attribute>
                  <xs:attribute name="order" type="xs:integer" use="optional"/>
                  <xs:attribute name="browser-condition" type="fm:entered-string" use="optional"/>
                </xs:complexType>
              </xs:element>
            </xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name="presentation" type="fm:presentation-type"/>
        <xs:element name="state-list">
          <xs:complexType>
            <xs:sequence>
              <xs:element name="state" minOccurs="0" maxOccurs="unbounded">
                <xs:complexType>
                  <xs:sequence>
                    <xs:element name="documentation" type="fm:documentation" minOccurs="0"/>
                    <xs:element name="xpath-list" minOccurs="0" type="fm:xpath-list-type">
                      <xs:unique name="unique-xpath-name-within-state">
                        <xs:selector xpath="./fm:xpath"/>
                        <xs:field xpath="@name"/>
                      </xs:unique>
                    </xs:element>
                    <xs:element name="action-list" minOccurs="0">
                      <xs:complexType>
                        <xs:complexContent>
                          <xs:extension base="fm:action-list-type"/>
                        </xs:complexContent>
                      </xs:complexType>
                    </xs:element>
                    <xs:element name="presentation" type="fm:presentation-type" minOccurs="0"/>
                  </xs:sequence>
                  <xs:attribute name="name" type="fm:entered-string" use="required">
                    <xs:annotation>
                      <xs:documentation>A programmatic name. This name will never be presented to
                        the user but is used to identify this module component in a programmtic
                        sense. </xs:documentation>
                    </xs:annotation>
                  </xs:attribute>
                  <xs:attribute name="title" type="xs:string" use="optional">
                    <xs:annotation>
                      <xs:documentation>Defaults to the value of the name attribute, if not
                        specified.</xs:documentation>
                      <xs:documentation>A human-readable short title. The title may be presented to
                        the user.</xs:documentation>
                    </xs:annotation>
                  </xs:attribute>
                  <xs:attribute name="description" type="xs:string" use="optional">
                    <xs:annotation>
                      <xs:documentation>Defaults to the value of the title attribute, if not
                        specified.</xs:documentation>
                      <xs:documentation>A short description that clearly states the purpose of the
                        module component. The description may be presented to the end user, if not
                        specified.</xs:documentation>
                    </xs:annotation>
                  </xs:attribute>
                  <xs:attribute name="stub-overload"/>
                  <xs:attribute name="build-only"/>
                </xs:complexType>
              </xs:element>
            </xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name="template-list">
          <xs:complexType>
            <xs:sequence>
              <xs:element name="template" minOccurs="0" maxOccurs="unbounded">
                <xs:complexType>
                  <xs:sequence>
                    <xs:any namespace="##any" processContents="skip" minOccurs="0" maxOccurs="unbounded"/>
                  </xs:sequence>
                  <xs:attribute name="name" type="fm:entered-string" use="required"/>
                  <xs:attribute name="stub-only"/>
                  <xs:attribute name="build-only"/>
                </xs:complexType>
              </xs:element>
            </xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name="map-set-list">
          <xs:complexType>
            <xs:sequence>
              <xs:element name="map-set" minOccurs="0" maxOccurs="unbounded">
                <xs:annotation>
                  <xs:documentation>A container for key and data items such as those used in html
                    LOV pulldowns. <!--
Mapsets can have the following structures:

  A) A simple map set

  <mapset>
     <rec>
         <key>
           {value}
         </key>
         <data>
           {value}
         </data>

  B) A complex map set:

  <mapset>
     <rec>
         <key>
           <{keyname1..}>
                  {value}
           </{keyname1}>
                ...
         </key>
         <data>
             <{dataname..}>
                 {value}
             </{dataname}>
             ...
          </data>
  -->
                  </xs:documentation>
                </xs:annotation>
                <xs:complexType>
                  <xs:sequence>
                    <xs:choice maxOccurs="1" minOccurs="0">
                      <xs:element name="storage-location">
                        <xs:annotation>
                          <xs:documentation>The storage location where the map set is to be
                            stored</xs:documentation>
                        </xs:annotation>
                      </xs:element>
                      <xs:element name="dom-query" nillable="false">
                        <xs:annotation>
                          <xs:documentation>Specify a query which will return a single scalar column containing the mapset XML. The selected column can be a CLOB or XMLType. XML should be in the format:  /map-set-list/map-set/rec/{key | data}</xs:documentation>
                        </xs:annotation>
                        <xs:complexType>
                          <xs:attributeGroup ref="fm:mapset-interface-query-attr-grp"/>
                        </xs:complexType>
                      </xs:element>
                      <xs:element name="record-query" nillable="false">
                        <xs:annotation>
                          <xs:documentation>Specify a query which will return one or more rows. Each row will be treated as a 'rec' element in the mapset with 'key' and 'data' columns. There is no need to specify a target-path on the query.

                            The 'data' column may be a string or an XMLType. For XML, the content of the XMLType's root element will be treated as the content of the 'data' element. The 'key' column must always be a string.</xs:documentation>
                        </xs:annotation>
                        <xs:complexType>
                          <xs:attributeGroup ref="fm:mapset-interface-query-attr-grp"/>
                          <xs:attribute name="key-column-name">
                            <xs:annotation>
                              <xs:documentation>Specify the name of the column which should be treated as the mapset's 'key' element. If not specified a default of "key" is assumed. Note that column names are case sensitive.</xs:documentation>
                            </xs:annotation>
                          </xs:attribute>
                          <xs:attribute name="data-column-name">
                            <xs:annotation>
                              <xs:documentation>Specify the name of the column which should be treated as the mapset's 'data' element. If not specified a default of "data" is assumed. Note that column names are case sensitive.</xs:documentation>
                            </xs:annotation>
                          </xs:attribute>
                        </xs:complexType>
                      </xs:element>
                      <xs:element name="ajax-definition" nillable="false">
                        <xs:annotation>
                          <xs:documentation>Specify a search query which will return one or more rows. Each row will be treated as a 'rec' element in the mapset with 'key' and 'data' columns. There is no need to specify a target-path on the query.
                            Also specify a ref query which will return only one row for a given reference. The row will be treated as a 'rec' element in the mapset with 'key' and 'data' columns. There is no need to specify a target-path on the query.

                            The 'data' column may be a string or an XMLType. For XML, the content of the XMLType's root element will be treated as the content of the 'data' element. The 'key' column must always be a string.
                            If the 'data' column is defined as XMLType you MUST define a ref-path attribute here to resolve a reference from the xml data.
                          </xs:documentation>
                        </xs:annotation>
                        <xs:complexType>
                          <xs:attribute name="interface" type="fm:entered-string" use="required">
                            <xs:annotation>
                              <xs:documentation>Name of database interface containing mapset querys.</xs:documentation>
                            </xs:annotation>
                          </xs:attribute>
                          <xs:attribute name="search-query" type="fm:entered-string" use="required">
                            <xs:annotation>
                              <xs:documentation>Name of mapset query within the db-interface that uses :search_term to get mapset records.</xs:documentation>
                            </xs:annotation>
                          </xs:attribute>
                          <xs:attribute name="search-query-result-limit" type="xs:integer" use="optional">
                            <xs:annotation>
                              <xs:documentation>Number of search result records to return to users. Default = 100</xs:documentation>
                            </xs:annotation>
                          </xs:attribute>
                          <xs:attribute name="ref-query" type="fm:entered-string" use="required">
                            <xs:annotation>
                              <xs:documentation>Name of mapset query within the db-interface that uses :ref to get the corresponding mapset record.</xs:documentation>
                            </xs:annotation>
                          </xs:attribute>
                          <xs:attribute name="ref-path" type="fm:fox-xpath-type" use="optional">
                            <xs:annotation>
                              <xs:documentation>Simple XPATH to get a unique reference from inside an XML data item.</xs:documentation>
                            </xs:annotation>
                          </xs:attribute>
                        </xs:complexType>
                      </xs:element>
                      <xs:element name="record-list" type="mapset-rec-list">
                        <xs:annotation>
                          <xs:documentation>Specify the mapset 'rec' list.</xs:documentation>
                        </xs:annotation>
                      </xs:element>
                      <xs:element name="template">
                        <xs:annotation>
                          <xs:documentation>Specify a template containing the mapset XML. The format of XML in the template should be: /map-set/rec/{key | data}</xs:documentation>
                        </xs:annotation>
                        <xs:complexType>
                          <xs:attribute name="name" use="required"/>
                        </xs:complexType>
                      </xs:element>
                      <xs:element name="database-definition">
                        <xs:annotation>
                          <xs:documentation>Specify the name (domain) of a mapset which is defined in a predetermined database table (typically configured on the module's app).</xs:documentation>
                        </xs:annotation>
                        <xs:complexType>
                          <xs:attribute name="domain" use="required"/>
                        </xs:complexType>
                      </xs:element>
                    </xs:choice>
                    <xs:element name="do" type="fm:do-block-type" minOccurs="0" form="qualified">
                      <xs:annotation>
                        <xs:documentation>Commands to be run against the mapset DOM after it has been initialised. If you specfiy a do block you will need to explicitly define a cache key.</xs:documentation>
                      </xs:annotation>
                    </xs:element>
                    <xs:element name="cache-key" minOccurs="0">
                      <xs:annotation>
                        <xs:documentation>Definition of the key which this mapset will be cached against. The cache-key should contain all the values which make this mapset unique.</xs:documentation>
                      </xs:annotation>
                      <xs:complexType>
                        <xs:sequence>
                          <xs:group ref="fm:using-clause-grp"/>
                        </xs:sequence>
                        <xs:attribute fixed="unique" name="type">
                          <xs:annotation>
                            <xs:documentation>Shortcut markup for defining a unique cache key. The FOX engine will generate a unique cache key definition for you if you specify this attribute - there is no need to define any using clauses.</xs:documentation>
                          </xs:annotation>
                        </xs:attribute>
                        <xs:attribute name="string" type="xs:string" use="optional"/>
                      </xs:complexType>
                    </xs:element>
                    <xs:choice minOccurs="0">
                      <xs:element name="refresh-timeout-mins">
                        <xs:annotation>
                          <xs:documentation>If the refresh-timeout is expired then the next time a map
                            set is accessed the contents will be reloaded</xs:documentation>
                        </xs:annotation>
                        <xs:simpleType>
                          <xs:restriction base="xs:integer">
                            <xs:minInclusive value="0"/>
                          </xs:restriction>
                        </xs:simpleType>
                      </xs:element>
                      <xs:element name="refresh">
                        <xs:annotation>
                          <xs:documentation>Specify when the mapset should be refreshed. Use this as a replacement for refresh-timeout-mins - a value of '0' maps to 'always', a high value such as '999999999' maps to 'never'.</xs:documentation>
                        </xs:annotation>
                        <xs:simpleType>
                          <xs:restriction base="xs:string">
                            <xs:enumeration value="always"/>
                            <xs:enumeration value="never"/>
                          </xs:restriction>
                        </xs:simpleType>
                      </xs:element>
                    </xs:choice>
                    <xs:element name="refresh-in-background" type="xs:boolean" minOccurs="0">
                      <xs:annotation>
                        <xs:documentation>Deprecated syntax - please remove instances of this element where it appears.</xs:documentation>
                      </xs:annotation>
                    </xs:element>
                  </xs:sequence>
                  <xs:attribute name="name" type="fm:entered-string" use="required"/>
                  <xs:attribute name="stub-overload"/>
                  <xs:attribute name="build-only"/>
                </xs:complexType>
              </xs:element>
            </xs:sequence>
          </xs:complexType>
          <xs:key name="map-set-pk">
            <xs:selector xpath="fm:map-set"/>
            <xs:field xpath="@name"/>
          </xs:key>
        </xs:element>
        <xs:element name="pagination-definition-list" minOccurs="0">
          <xs:complexType>
            <xs:sequence>
              <xs:element name="pagination-definition" minOccurs="0" maxOccurs="unbounded">
                <xs:complexType>
                  <xs:sequence>
                    <xs:element name="page-size">
                      <xs:annotation>
                        <xs:documentation>The initial number of rows per page for this pager. The page size can be modified dynamically by the fm:go-to-page command.</xs:documentation>
                      </xs:annotation>
                    </xs:element>
                    <xs:element name="pre-page" minOccurs="0">
                      <xs:annotation>
                        <xs:documentation>Actions to run before the page is changed. If you specify a pre-page action on a database pager, you are responsible for removing the old page's data from the containing element if you require this behaviour. To prevent the page change action from completing, throw an ACTIONBREAK.</xs:documentation>
                      </xs:annotation>
                      <xs:complexType>
                        <xs:sequence>
                          <xs:element name="do" type="fm:do-block-type"/>
                        </xs:sequence>
                      </xs:complexType>
                    </xs:element>
                    <xs:element name="post-page" minOccurs="0">
                      <xs:annotation>
                        <xs:documentation>Actions to run after the page has changed and the new page data has been loaded into the DOM.</xs:documentation>
                      </xs:annotation>
                      <xs:complexType>
                        <xs:sequence>
                          <xs:element name="do" type="fm:do-block-type"/>
                        </xs:sequence>
                      </xs:complexType>
                    </xs:element>
                    <xs:element minOccurs="0" name="page-controls">
                      <xs:annotation>
                        <xs:documentation>Options for how the page controls are displayed for any pagers using this pagination definition.</xs:documentation>
                      </xs:annotation>
                      <xs:complexType>
                        <xs:sequence>
                          <xs:element name="first-page" minOccurs="0" type="fm:page-control-button-config">
                            <xs:annotation>
                              <xs:documentation>Options for how the page controls display the "first page" button.</xs:documentation>
                            </xs:annotation>
                          </xs:element>
                          <xs:element name="previous-page" minOccurs="0" type="fm:page-control-button-config">
                            <xs:annotation>
                              <xs:documentation>Options for how the page controls display the "previous page" button.</xs:documentation>
                            </xs:annotation>
                          </xs:element>
                          <xs:element name="next-page" minOccurs="0" type="fm:page-control-button-config">
                            <xs:annotation>
                              <xs:documentation>Options for how the page controls display the "next page" button.</xs:documentation>
                            </xs:annotation>
                          </xs:element>
                          <xs:element name="last-page" minOccurs="0" type="fm:page-control-button-config">
                            <xs:annotation>
                              <xs:documentation>Options for how the page controls display the "last page" button.</xs:documentation>
                            </xs:annotation>
                          </xs:element>
                          <xs:element minOccurs="0" name="page-count">
                            <xs:annotation>
                              <xs:documentation>Options for how the page count is displayed in the page controls.</xs:documentation>
                            </xs:annotation>
                            <xs:complexType>
                              <xs:attribute name="enabled" type="xs:boolean">
                                <xs:annotation>
                                  <xs:documentation>If true, the page count will be displayed. If false it is hidden. Default depends on the page control style.</xs:documentation>
                                </xs:annotation>
                              </xs:attribute>
                            </xs:complexType>
                          </xs:element>
                          <xs:element minOccurs="0" name="single-page">
                            <xs:annotation>
                              <xs:documentation>Options for how the pager handles the display of a single page.</xs:documentation>
                            </xs:annotation>
                            <xs:complexType>
                              <xs:attribute name="hide-controls" type="xs:boolean">
                                <xs:annotation>
                                  <xs:documentation>If true, controls will be hidden for a single page. If false, controls are always displayed. Default is true.</xs:documentation>
                                </xs:annotation>
                              </xs:attribute>
                            </xs:complexType>
                          </xs:element>
                          <xs:element minOccurs="0" name="creeper">
                            <xs:annotation>
                              <xs:documentation>Options specific to the "creeper" control style, used by Top-N pagination.</xs:documentation>
                            </xs:annotation>
                            <xs:complexType>
                              <xs:attribute name="page-scope" type="xs:integer" use="required">
                                <xs:annotation>
                                  <xs:documentation>How many page numbers to display before and after the currently selected page in the creeper. E.g. with a value of "2", on page 3 the display will be "1 2 [3] 4 5".</xs:documentation>
                                </xs:annotation>
                              </xs:attribute>
                            </xs:complexType>
                          </xs:element>
                        </xs:sequence>
                        <xs:attribute name="style" use="required">
                          <xs:annotation>
                            <xs:documentation>Choose a baseline style for the page controls which can then be customised by the child elements of fm:page-control.</xs:documentation>
                          </xs:annotation>
                          <xs:simpleType>
                            <xs:restriction base="xs:string">
                              <xs:enumeration value="simple"/>
                              <xs:enumeration value="standard"/>
                              <xs:enumeration value="full"/>
                              <xs:enumeration value="creeper"/>
                            </xs:restriction>
                          </xs:simpleType>
                        </xs:attribute>
                      </xs:complexType>
                    </xs:element>
                  </xs:sequence>
                  <xs:attribute name="name" type="fm:entered-string" use="required"/>
                </xs:complexType>
              </xs:element>
            </xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name="client-visibility-rule-list" minOccurs="0">
          <xs:annotation>
            <xs:documentation>Container for client visibility rules.</xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence>
              <xs:element name="client-visibility-rule" minOccurs="0" maxOccurs="unbounded">
                <xs:annotation>
                  <xs:documentation>A client visibility rule defines conditions for when client side code (e.g. Javascript) is used to control field visibility, in addition to namespace rules.</xs:documentation>
                </xs:annotation>
                <xs:complexType>
                  <xs:sequence>
                    <xs:element name="condition" type="fm:client-visibility-rule-condition-type"/>
                  </xs:sequence>
                  <xs:attribute name="name" type="fm:entered-string" use="required">
                    <xs:annotation>
                      <xs:documentation>Unique name of the client visibility rule. This will be used as a key when merging modules.</xs:documentation>
                    </xs:annotation>
                  </xs:attribute>
                  <xs:attribute name="use-css-visibility" type="fm:fox-xpath-type" use="optional">
                    <xs:annotation>
                      <xs:documentation>Specify a boolean XPath. If evaluated to true, the CSS "visibility" property will be used instead of the "display" property to control showing or hiding of the target element. Default is "false" if not specified.</xs:documentation>
                    </xs:annotation>
                  </xs:attribute>
                </xs:complexType>
              </xs:element>
            </xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name="data-definition-list" minOccurs="0">
          <xs:annotation>
            <xs:documentation>aaa</xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence>
              <xs:element name="data-definition" minOccurs="1" maxOccurs="unbounded">
                <xs:annotation>
                  <xs:documentation>Definition block describing how data should be queried and transformed for use client side</xs:documentation>
                </xs:annotation>
                <xs:complexType>
                  <xs:sequence>
                    <xs:element name="data-query">
                      <xs:complexType>
                        <xs:annotation>
                          <xs:documentation>The query to use when getting data for this data-definition</xs:documentation>
                        </xs:annotation>
                        <xs:attribute name="interface" type="fm:entered-string" use="required">
                          <xs:annotation>
                            <xs:documentation>The name of the db-interface to get the query from</xs:documentation>
                          </xs:annotation>
                        </xs:attribute>
                        <xs:attribute name="query" type="fm:entered-string" use="required">
                          <xs:annotation>
                            <xs:documentation>The name of the query within the interface that will be executed for each node matched from the match tag</xs:documentation>
                          </xs:annotation>
                        </xs:attribute>
                      </xs:complexType>
                    </xs:element>
                    <xs:element name="ajax-data" type="xs:boolean" minOccurs="0">
                      <xs:annotation>
                        <xs:documentation>If you expect a large amount of data you can have the data be accessed via AJAX to potentially improve the perception of speed</xs:documentation>
                      </xs:annotation>
                    </xs:element>
                    <xs:element name="transformer" minOccurs="1">
                      <xs:annotation>
                        <xs:documentation>Specify how the data is transformed from the query result to the javascript access.</xs:documentation>
                      </xs:annotation>
                      <xs:simpleType>
                        <xs:restriction base="xs:string">
                          <xs:enumeration value="object"/>
                          <xs:enumeration value="array"/>
                        </xs:restriction>
                      </xs:simpleType>
                    </xs:element>
                    <xs:element name="column-mapping" minOccurs="0">
                      <xs:annotation>
                        <xs:documentation>Definition block describing how data should be queried and transformed for use client side</xs:documentation>
                      </xs:annotation>
                      <xs:complexType>
                        <xs:sequence>
                          <xs:element name="series" minOccurs="0"/>
                          <xs:element name="x" minOccurs="0"/>
                          <xs:element name="y" minOccurs="0"/>
                        </xs:sequence>
                      </xs:complexType>
                    </xs:element>
                    <xs:element name="cache-key" minOccurs="0">
                      <xs:annotation>
                        <xs:documentation>Definition of the key which this data definition will be cached against. The cache-key should contain all the values which make this data definition unique.</xs:documentation>
                      </xs:annotation>
                      <xs:complexType>
                        <xs:sequence>
                          <xs:group ref="fm:using-clause-grp"/>
                        </xs:sequence>
                        <xs:attribute fixed="unique" name="type">
                          <xs:annotation>
                            <xs:documentation>Shortcut markup for defining a unique cache key. The FOX engine will generate a unique cache key definition for you if you specify this attribute - there is no need to define any using clauses.</xs:documentation>
                          </xs:annotation>
                        </xs:attribute>
                        <xs:attribute name="string" type="xs:string" use="optional"/>
                      </xs:complexType>
                    </xs:element>
                    <xs:choice minOccurs="0">
                      <xs:element name="refresh-timeout-mins">
                        <xs:annotation>
                          <xs:documentation>If the refresh-timeout is expired then the next time a data definition is accessed the contents will be reloaded</xs:documentation>
                        </xs:annotation>
                        <xs:simpleType>
                          <xs:restriction base="xs:integer">
                            <xs:minInclusive value="0"/>
                          </xs:restriction>
                        </xs:simpleType>
                      </xs:element>
                      <xs:element name="refresh">
                        <xs:annotation>
                          <xs:documentation>Specify when the data definition should be refreshed. Use this as an alternative for refresh-timeout-mins - a value of 'always' maps to '0', a value of 'never' maps to '999999999'.</xs:documentation>
                        </xs:annotation>
                        <xs:simpleType>
                          <xs:restriction base="xs:string">
                            <xs:enumeration value="always"/>
                            <xs:enumeration value="never"/>
                          </xs:restriction>
                        </xs:simpleType>
                      </xs:element>
                    </xs:choice>
                  </xs:sequence>
                  <xs:attribute name="name" type="fm:entered-string" use="required">
                    <xs:annotation>
                      <xs:documentation>Unique name of the data-definition. This will be used asthe key to use in an implicated-data-definition-list inside a states presentation block.</xs:documentation>
                    </xs:annotation>
                  </xs:attribute>
                </xs:complexType>
              </xs:element>
            </xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name="page-definition-list" minOccurs="0">
          <xs:annotation>
            <xs:documentation>A list of page definitions used for PDF generation</xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence>
              <xs:element name="page-definition" minOccurs="0" maxOccurs="unbounded">
                <xs:annotation>
                  <xs:documentation>Defines the attributes of a page of a generated PDF document such as width, height, margins etc.</xs:documentation>
                </xs:annotation>
                <xs:complexType>
                  <xs:sequence>
                    <xs:element name="body" minOccurs="0" maxOccurs="1">
                      <xs:annotation>
                        <xs:documentation>Defines the attributes of the page body, i.e. the area that will contain the generated content</xs:documentation>
                      </xs:annotation>
                      <xs:complexType>
                        <xs:attribute name="margin-left" type="fm:entered-string" use="required"/>
                        <xs:attribute name="margin-right" type="fm:entered-string" use="required"/>
                        <xs:attribute name="margin-top" type="fm:entered-string" use="required"/>
                        <xs:attribute name="margin-bottom" type="fm:entered-string" use="required"/>
                      </xs:complexType>
                    </xs:element>
                    <xs:element name="header" minOccurs="0" maxOccurs="1">
                      <xs:annotation>
                        <xs:documentation>Defines the attributes of the page header, i.e. the area within the page margins above page body</xs:documentation>
                      </xs:annotation>
                      <xs:complexType>
                        <xs:attribute name="height" type="fm:entered-string" use="required"/>
                      </xs:complexType>
                    </xs:element>
                    <xs:element name="footer" minOccurs="0" maxOccurs="1">
                      <xs:annotation>
                        <xs:documentation>Defines the attributes of the page footer, i.e. the area within the page margins below page body</xs:documentation>
                      </xs:annotation>
                      <xs:complexType>
                        <xs:attribute name="height" type="fm:entered-string" use="required"/>
                      </xs:complexType>
                    </xs:element>
                  </xs:sequence>
                  <xs:attribute name="name" type="fm:entered-string" use="required">
                    <xs:annotation>
                      <xs:documentation>The name of the page definition, used to reference it when generating PDF content</xs:documentation>
                    </xs:annotation>
                  </xs:attribute>
                  <xs:attribute name="page-width" type="fm:entered-string" use="required"/>
                  <xs:attribute name="page-height" type="fm:entered-string" use="required"/>
                  <xs:attribute name="margin-left" type="fm:entered-string" use="required"/>
                  <xs:attribute name="margin-right" type="fm:entered-string" use="required"/>
                  <xs:attribute name="margin-top" type="fm:entered-string" use="required"/>
                  <xs:attribute name="margin-bottom" type="fm:entered-string" use="required"/>
                </xs:complexType>
              </xs:element>
            </xs:sequence>
          </xs:complexType>
        </xs:element>
      </xs:sequence>
    </xs:complexType>
  </xs:element>
  <xs:complexType name="do-block-type">
    <xs:sequence>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:element name="attach">
          <xs:complexType>
            <xs:attribute name="to" type="fm:fox-xpath-type" use="required"/>
          </xs:complexType>
        </xs:element>
        <xs:element name="run-api">
          <xs:annotation>
            <xs:documentation>Call a API interface to process database records. </xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:attribute name="match" type="fm:fox-xpath-type" default=".">
              <xs:annotation>
                <xs:documentation>Specifies the pathname of context nodes to process.
                </xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="interface" type="fm:entered-string" use="required">
              <xs:annotation>
                <xs:documentation>The interface attribute is the name of the db-interface to use
                </xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="mode">
              <xs:annotation>
                <xs:documentation>overides default mode for API</xs:documentation>
              </xs:annotation>
              <xs:simpleType>
                <xs:restriction base="fm:entered-string">
                  <xs:enumeration value="PURGE-SELECTED"/>
                  <xs:enumeration value="PURGE-ALL"/>
                  <xs:enumeration value="AUGMENT"/>
                  <xs:enumeration value="ADD-TO"/>
                </xs:restriction>
              </xs:simpleType>
            </xs:attribute>
            <xs:attribute name="api" type="fm:entered-string"/>
          </xs:complexType>
        </xs:element>
        <xs:element name="run-query">
          <xs:complexType>
            <xs:annotation>
              <xs:documentation>Call a DML interface to query or lock database records.
              </xs:documentation>
            </xs:annotation>
            <xs:attribute name="match" type="fm:fox-xpath-type" default=".">
              <xs:annotation>
                <xs:documentation>match specifies the pathname of context nodes to process.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="interface" type="fm:entered-string" use="required">
              <xs:annotation>
                <xs:documentation>The interface attribute is the name of the db-interface to use
                </xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="mode">
              <xs:annotation>
                <xs:documentation>ovverides default mode for query</xs:documentation>
              </xs:annotation>
              <xs:simpleType>
                <xs:restriction base="fm:entered-string">
                  <xs:enumeration value="PURGE-SELECTED"/>
                  <xs:enumeration value="PURGE-ALL"/>
                  <xs:enumeration value="AUGMENT"/>
                  <xs:enumeration value="ADD-TO"/>
                </xs:restriction>
              </xs:simpleType>
            </xs:attribute>
            <xs:attribute name="query" type="fm:entered-string">
              <xs:annotation>
                <xs:documentation>the name of the query within the interface that will be executed
                  for each node matched from the match tag</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="pagination-invoke-name" type="fm:entered-string" use="optional"/>
            <xs:attribute name="pagination-definition" type="fm:entered-string" use="optional"/>
            <xs:attribute name="page-size" type="fm:entered-string" use="optional"/>
            <xs:attribute name="cache-binds" type="fm:entered-string" use="optional">
              <xs:annotation>
                <xs:documentation>For Top-N paginated queries, the default behaviour is to cache bind variable values at initial execution time and use the cached binds when the page is changed. If this attribute is defined and returns false when evaluated as an XPath, the caching behaviour will be disabled. You cannot define this attribute unless the query is a Top-N paginated query.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
          </xs:complexType>
        </xs:element>
        <xs:element name="run-query2">
          <xs:complexType>
            <xs:annotation>
              <xs:documentation>Call a DML interface to query or lock database records. </xs:documentation>
            </xs:annotation>
            <xs:attribute name="match" type="fm:fox-xpath-type" default=".">
              <xs:annotation>
                <xs:documentation>The pathname of context nodes to process.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="interface" type="fm:entered-string" use="required">
              <xs:annotation>
                <xs:documentation>The interface attribute is the name of the db-interface to use </xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="mode">
              <xs:annotation>
                <xs:documentation>Overrides default mode for query</xs:documentation>
              </xs:annotation>
              <xs:simpleType>
                <xs:restriction base="fm:entered-string">
                  <xs:enumeration value="PURGE-SELECTED"/>
                  <xs:enumeration value="PURGE-ALL"/>
                  <xs:enumeration value="AUGMENT"/>
                  <xs:enumeration value="ADD-TO"/>
                </xs:restriction>
              </xs:simpleType>
            </xs:attribute>
            <xs:attribute name="query" type="fm:entered-string">
              <xs:annotation>
                <xs:documentation>The name of the query within the interface that will be executed for each node matched from the match tag</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="pagination-invoke-name" type="fm:entered-string" use="optional"/>
            <xs:attribute name="pagination-definition" type="fm:entered-string" use="optional"/>
            <xs:attribute name="page-size" type="fm:entered-string" use="optional"/>
          </xs:complexType>
        </xs:element>
        <xs:element name="assign">
          <xs:annotation>
            <xs:documentation>Assign a textual or XPath-expression value to a specified target node
              or nodes list. setTarget assigns nodes that exist only, whereas initTarget creates
              nodes if they dont exist.</xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:attribute name="setTarget" type="fm:fox-xpath-type" use="optional"/>
            <xs:attribute name="initTarget" type="fm:fox-xpath-type" use="optional"/>
            <xs:attribute name="textValue" type="xs:string" use="optional"/>
            <xs:attribute name="expr" type="fm:fox-xpath-type" use="optional"/>
          </xs:complexType>
        </xs:element>
        <xs:element name="init">
          <xs:annotation>
            <xs:documentation>Initialise elements from a named template or from the data schema. If
              initialising from the schema, schema elements can make use of the 'default' or 'fixed'
              value attributes. </xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence>
              <xs:any namespace="##any" processContents="skip" minOccurs="0" maxOccurs="unbounded"/>
            </xs:sequence>
            <xs:attribute name="target" type="fm:fox-xpath-type" use="optional" default=".">
              <xs:annotation>
                <xs:documentation>The target(s) to initialise, relative to the current attach point.
                  The specified target(s) may exist in the Data DOM, or refer to nodes in the Model
                  DOM (via simple XPath) or may be a user-defined path. Whether existing targetted
                  nodes are initialised or new nodes are created depends on the value of the
                  'method' attribute.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="template" type="fm:entered-string" use="optional">
              <xs:annotation>
                <xs:documentation>The name of the template, within the module, to call. Note that
                  all child nodes of the template are used in the initialisation process and those
                  nodes MUST be in the same XML namespace - the empty namespace ("") - as the
                  DATA/Model DOM.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="for-schema" type="fm:entered-string" use="optional" default=".">
              <xs:annotation>
                <xs:documentation>The elements from the Model DOM, relative to the specified target
                  node(s), that are to be initialised under the target node(s).</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="min-occurs" type="fm:fox-xpath-type" use="optional">
              <xs:annotation>
                <xs:documentation>If the method is 'new' or 'both', the minimum number of target
                  node types to ensure exist. Nodes may be created in order to bring the total
                  number of target node types up to the minimum specified. </xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="max-occurs" type="fm:fox-xpath-type" use="optional">
              <xs:annotation>
                <xs:documentation>If the method is 'new' or 'both', the maximum number of target
                  node types that will exist as a result of the initialise operation. The initialise
                  operation will never exceed the specified maximum bound when new target node(s)
                  are created. Depending on the value of the 'new-target-count' attribute, the
                  number of target nodes may be brought up to the specified maximum
                  bound.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="method" use="optional" default="both">
              <xs:annotation>
                <xs:documentation>The initialisation method: new, augment or both (the default). The
                  targetted node(s) are initialised from the specified template or schema elements.
                  The template or schema elements will be initialised as new children of the
                  targetted node(s). If the method is 'new', the 'new-target-count' attribute should
                  be used to specify the number of new targets required. The 'min-occurs' and
                  'max-occurs' attributes may also be specified to bring the number of target node
                  type instances up to the specified minimum number and up to, but not exceeding,
                  the maximum number. If the method is 'augment', only existing target nodes will be
                  initialised. Any child nodes, of the targetted nodes, that do not have any content
                  will be initialised according to their configured initialisation attributes from
                  the Model DOM. For the method of 'both', which is the default method, any target
                  nodes that exist and any required new target node instances (refer to the 'new'
                  and 'augment' attributes) are initialised. </xs:documentation>
              </xs:annotation>
              <xs:simpleType>
                <xs:restriction base="fm:entered-string">
                  <xs:enumeration value="both">
                    <xs:annotation>
                      <xs:documentation>The default mode. The initialise command may potentially,
                        depending on your new-target-count, min-occurs or max-occurs attributes,
                        create new instances of the target node type and augment any existing
                        intances it finds.</xs:documentation>
                    </xs:annotation>
                  </xs:enumeration>
                  <xs:enumeration value="new">
                    <xs:annotation>
                      <xs:documentation>The initialise command may potentially, depending on your
                        new-target-count, min-occurs or max-occurs attributes, create new instances
                        of the target node type and ONLY initialise those new instances created. Any
                        existing intances of the target node type will not be initialised by this
                        invocation on init.</xs:documentation>
                    </xs:annotation>
                  </xs:enumeration>
                  <xs:enumeration value="augment">
                    <xs:annotation>
                      <xs:documentation>In this mode, the initialise command will only add to any
                        existing intances of the target node type it finds. Any descendants of
                        existing targets will be recursively searched and created where they do not
                        yet exist according to the meta-model.</xs:documentation>
                    </xs:annotation>
                  </xs:enumeration>
                </xs:restriction>
              </xs:simpleType>
            </xs:attribute>
            <xs:attribute name="new-target-count" type="fm:fox-xpath-type" use="optional"/>
          </xs:complexType>
        </xs:element>
        <xs:element name="if">
          <xs:annotation>
            <xs:documentation>An industry standard if-then-else-if-else like
              command.</xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence>
              <xs:element name="then" type="fm:do-block-type"/>
              <xs:element name="else-if" minOccurs="0" maxOccurs="unbounded">
                <xs:complexType>
                  <xs:complexContent>
                    <xs:extension base="fm:do-block-type">
                      <xs:attribute name="test" type="xs:string" use="required"/>
                    </xs:extension>
                  </xs:complexContent>
                </xs:complexType>
              </xs:element>
              <xs:element name="else" type="fm:do-block-type" minOccurs="0"/>
            </xs:sequence>
            <xs:attribute name="test" type="fm:fox-xpath-type" use="required"/>
          </xs:complexType>
        </xs:element>
        <xs:element name="case">
          <xs:annotation>
            <xs:documentation>A searched case statement similar to the Oracle PL/SQL implementation.

              If present, the attribute "expr" is evaluated and must yield a single value, otherwise the "value" attribute
              must be set. In either case, the single string value yielded will be checked against each fm:when element in
              turn until a match is found, or fm:default is reached.

              fm:when elements also have the attributes "expr" and "value", only one may be set. If the "value" attribute
              or the value resulting from the "expr" attribute match the value of the fm:case, then the action contents of
              fm:case are evaluated.

              If the "continue-matching" attribute is set to "true", then after the fm:when contents are evaluated, the
              command will continue to compare the original value against the subsequent fm:when element(s) until a further
              match is found, or fm:default is reached. This allows multiple fm:when elements to be evaluated if desired.

              If the fm:default element is reached, then its contents are evaluated.
            </xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence>
              <xs:element name="when" maxOccurs="unbounded">
                <xs:complexType>
                  <xs:complexContent>
                    <xs:extension base="fm:do-block-type">
                      <xs:attributeGroup ref="fm:case-attr-grp"/>
                      <xs:attribute name="continue-matching" type="xs:boolean" use="optional"/>
                    </xs:extension>
                  </xs:complexContent>
                </xs:complexType>
              </xs:element>
              <xs:element name="default" type="fm:do-block-type" minOccurs="0"/>
            </xs:sequence>
            <xs:attributeGroup ref="fm:case-attr-grp"/>
          </xs:complexType>
        </xs:element>
        <xs:element name="move">
          <xs:annotation>
            <xs:documentation>Moves elements from a named location to a new
              destination.</xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:attribute name="from" type="fm:fox-xpath-type" use="optional" default="."/>
            <xs:attribute name="to" type="fm:fox-xpath-type" use="optional" default="."/>
          </xs:complexType>
        </xs:element>
        <xs:element name="copy">
          <xs:annotation>
            <xs:documentation>Copies elements from a named location to another
              location.</xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:attribute name="from" type="fm:fox-xpath-type" use="optional" default="."/>
            <xs:attribute name="to" type="fm:fox-xpath-type" use="optional" default="."/>
            <xs:attribute name="materialise-mapsets" type="fm:fox-xpath-type" use="optional" default="."/>
          </xs:complexType>
        </xs:element>
        <xs:element name="augment">
          <xs:annotation>
            <xs:documentation>Copies elements from a named location to another, if an element sharing the name already exists in the target location, then the contents are replaced. Setting values-only to 'true' will suppress the creation of new elements, and will only replace content for elements that already exist in the target location.</xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:attribute name="from" type="fm:fox-xpath-type" use="required"/>
            <xs:attribute name="to" type="fm:fox-xpath-type" use="required"/>
            <xs:attribute name="values-only" type="xs:boolean" use="optional" default="false"/>
          </xs:complexType>
        </xs:element>
        <xs:element name="refresh-map-set">
          <xs:annotation>
            <xs:documentation>Deletes and refreshes the map set from scratch regardless of timeout
              settings</xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:attribute name="name" type="fm:entered-string" use="required"/>
          </xs:complexType>
        </xs:element>
        <xs:group ref="fm:validate-cmd-grp"/>
        <xs:group ref="fm:do-cmd-grp"/>
        <xs:group ref="fm:cmd-remove-grp"/>
        <xs:group ref="fm:cmd-pragma-grp"/>
        <xs:group ref="fm:cmd-call-grp"/>
        <xs:element name="try">
          <xs:complexType>
            <xs:sequence>
              <xs:element name="do" type="fm:do-block-type"/>
              <xs:element name="catch" minOccurs="0" maxOccurs="unbounded">
                <xs:complexType>
                  <xs:sequence>
                    <xs:element name="do" type="fm:do-block-type"/>
                  </xs:sequence>
                  <xs:attribute name="codes" type="xs:NMTOKENS" use="required"/>
                </xs:complexType>
              </xs:element>
              <xs:element name="finally" minOccurs="0">
                <xs:complexType>
                  <xs:sequence>
                    <xs:element name="do" type="fm:do-block-type"/>
                  </xs:sequence>
                </xs:complexType>
              </xs:element>
            </xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name="throw">
          <xs:complexType>
            <xs:attribute name="code" type="xs:string" use="required"/>
            <xs:attribute name="message" type="xs:string" use="required"/>
          </xs:complexType>
        </xs:element>
        <xs:element name="throw-break">
          <xs:complexType>
            <xs:attribute name="message" type="xs:string" use="optional"/>
          </xs:complexType>
        </xs:element>
        <xs:element name="throw-ignore">
          <xs:complexType>
            <xs:attribute name="message" type="xs:string" use="optional"/>
          </xs:complexType>
        </xs:element>
        <xs:element name="while">
          <xs:complexType>
            <xs:sequence>
              <xs:element name="do" type="fm:do-block-type"/>
            </xs:sequence>
            <xs:attribute name="xpath" type="fm:fox-xpath-type" use="required"/>
          </xs:complexType>
        </xs:element>
        <xs:element name="for-each">
          <xs:complexType>
            <xs:sequence>
              <xs:element name="do" type="fm:do-block-type"/>
            </xs:sequence>
            <xs:attribute name="xpath" type="fm:fox-xpath-type" use="optional"/>
            <xs:attribute name="itemContextName" type="xs:string" use="optional" default="loopItem"/>
            <xs:attribute name="statusContextName" type="xs:string" use="optional" default="loopStatus"/>
            <xs:attribute name="num-range-from" type="xs:double" use="optional" default="0"/>
            <xs:attribute name="num-range-to" type="xs:double" use="optional" default="-1"/>
            <xs:attribute name="num-range-step" type="xs:double" use="optional" default="1"/>
          </xs:complexType>
        </xs:element>
        <xs:element name="log">
          <xs:complexType>
            <xs:attribute name="message" type="fm:entered-string" use="required">
              <xs:annotation>
                <xs:documentation>The message to be logged to the current track (stringifiable).</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="xpath" type="fm:entered-string" use="optional">
              <xs:annotation>
                <xs:documentation>XPath to resolve any node or sequence. The result of this XPath will be dumped into the track XML.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
          </xs:complexType>
        </xs:element>
        <xs:element name="alert">
          <xs:annotation>
            <xs:documentation>Creates a dialog box on the screen next time the page loads.</xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:attribute name="message" type="fox:fox-xpath-string" use="optional">
              <xs:annotation>
                <xs:documentation>Alert message to display. Mutually exclusive with the 'buffer' attribute. Occurrences of '\n' in the message text are converted to line breaks. If the alert is displayed as a popover, the alert text may contain HTML tags.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="buffer" type="fox:fox-xpath-string">
              <xs:annotation>
                <xs:documentation>Name of a buffer containing complex content to display as the alert message. Mutually exclusive with the 'message' attribute. Buffer-based alerts can only be displayed as a popover. </xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="bufferAttach" type="fox:fox-xpath-dom">
              <xs:annotation>
                <xs:documentation>XPath resolving exactly one element to be used as the buffer attach point when an alert buffer is being evaluated. The default is the current state :{attach} point.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="display">
              <xs:annotation>
                <xs:documentation>Controls how a text-based alert is displayed. 'native' uses the browser's native alert control. 'popover' displays the alert content as a modal div, which may contain arbitrary HTML. The default is configured by the module-level display attr 'defaultAlertDisplay', which is 'popover' if undefined.</xs:documentation>
              </xs:annotation>
              <xs:simpleType>
                <xs:restriction base="xs:string">
                  <xs:enumeration value="native"/>
                  <xs:enumeration value="popover"/>
                </xs:restriction>
              </xs:simpleType>
            </xs:attribute>
            <xs:attribute name="alertType" default="normal">
              <xs:annotation>
                <xs:documentation>Built-in styling rules to apply to a 'popover' based alert.</xs:documentation>
              </xs:annotation>
              <xs:simpleType>
                <xs:union memberTypes="fox:notification-display-type">
                  <xs:simpleType>
                    <xs:restriction base="xs:string">
                      <xs:enumeration value="normal"/>
                    </xs:restriction>
                  </xs:simpleType>
                </xs:union>
              </xs:simpleType>
            </xs:attribute>
            <xs:attribute name="title" type="fox:fox-optional-xpath-string">
              <xs:annotation>
                <xs:documentation>Title for a popover alert.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="class" type="fox:fox-xpath-string">
              <xs:annotation>
                <xs:documentation>Additional CSS class(es) to add to the modal popover container for the alert.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="closePrompt" type="fox:fox-xpath-string">
              <xs:annotation>
                <xs:documentation>Prompt for the close button on a popover alert. The default is 'OK'.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
          </xs:complexType>
        </xs:element>
        <xs:element name="assert">
          <xs:annotation>
            <xs:documentation>Asserts that an XPath boolean condition evaluates to true.</xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:attribute name="message" type="xs:string" use="required"/>
            <xs:attribute name="test" type="xs:string" use="required"/>
          </xs:complexType>
        </xs:element>
        <xs:element name="assert-equals">
          <xs:annotation>
            <xs:documentation>Asserts that a node's string value is equal to either a specified constant value or an evaluated string value.</xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:attribute name="message" type="xs:string" use="required"/>
            <xs:attribute name="target" type="xs:string" use="required"/>
            <xs:attribute name="equals-expression" type="xs:string" use="optional"/>
            <xs:attribute name="equals-value" type="xs:string" use="optional"/>
          </xs:complexType>
        </xs:element>
        <xs:element name="assert-fails">
          <xs:annotation>
            <xs:documentation>Asserts that the nested actions cause an error to occur.</xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence>
              <xs:element name="do" type="fm:do-block-type"/>
            </xs:sequence>
            <xs:attribute name="message" type="xs:string" use="required"/>
          </xs:complexType>
        </xs:element>
        <xs:element name="focus">
          <xs:complexType>
            <xs:attribute name="xpath" type="xs:string" use="required">
              <xs:annotation>
                <xs:documentation>The element in the set out DOM to focus on.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="scrollYOffset" type="xs:integer">
              <xs:annotation>
                <xs:documentation>Offset from the target element to scroll.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
          </xs:complexType>
        </xs:element>
        <xs:element name="rename">
          <xs:complexType>
            <xs:attribute name="match" type="fm:fox-xpath-type" use="required"/>
            <xs:attribute name="rename-to" type="xs:string" use="required"/>
          </xs:complexType>
        </xs:element>
        <xs:element name="transaction">
          <xs:complexType>
            <xs:sequence>
              <xs:element name="do" type="fm:do-block-type" minOccurs="0"/>
            </xs:sequence>
            <xs:attribute name="operation" use="required">
              <xs:simpleType>
                <xs:restriction base="fm:entered-string">
                  <xs:enumeration value="COMMIT"/>
                  <xs:enumeration value="JOIN"/>
                  <xs:enumeration value="ROLLBACK"/>
                  <xs:enumeration value="SPLIT"/>
                  <xs:enumeration value="AUTONOMOUS"/>
                </xs:restriction>
              </xs:simpleType>
            </xs:attribute>
            <xs:attribute name="transaction" type="fm:entered-string" use="optional"/>
          </xs:complexType>
        </xs:element>
        <xs:element name="XSLTransform">
          <xs:annotation>
            <xs:documentation>Transforms XML with an XSLT style sheet.</xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:attribute name="source-xml-xpath" type="fm:fox-xpath-type" use="optional">
              <xs:annotation>
                <xs:documentation>The source root element of the data to be transformed. This may
                  refer to a file-type element, in which case the content of the file (assumed to be
                  XML) is used as the source.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="source-xsl-URI" type="fm:entered-string" use="optional">
              <xs:annotation>
                <xs:documentation>The source URI which may refer to an entry in the applications
                  resource table, for example "xsl/continuous-usage", a resource within the WAR or
                  EAR deployement or an external resource on the web. The resource is assumed to be
                  an XSL Style Sheet for Transformation (XSLT).</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="target-xpath" type="fm:fox-xpath-type" use="optional">
              <xs:annotation>
                <xs:documentation>The parent element under which the transformed data will be
                  placed.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
          </xs:complexType>
        </xs:element>
        <xs:element name="generate">
          <xs:annotation>
            <xs:documentation>Generate a fox display and then store the output (HTML) so it can be
              accessed later. Note that all database operations are currently performed in a
              discreet database transaction. Usage attrs: - state="state_name", is used to specify
              the display state to generate display with - when not specified current state is used.
              - buffer="state_name|MODULE/buffer_name", is used to specify the starting buffer to
              generate - when not specified special PAGE is used. - method="preview", the output is
              displayed immediately in a pop-up window - feature often used for Print Preview
              pop-up. - method="storage-location", the output will be saved using a standard fox
              storage location. Also need attrs: -- storage-location="storage_location_name", the
              name of the storage-location to use. - method="copy-to", the output (html node) is
              copied to one or more DOM elements. Also need attrs: -- copy-to-xpath="xpath", the dom
              nodes to copy html node to (will create dom node when does not exist). - method="url"
              (formally internal), the output is saved in fox server internally for access later via
              a URL. Also need attrs: -- url-xpath="xpath", (formally target="xpath") an element
              which will be assigned with the full URL string needed to access the output. --
              expires="HH:MM", duration to hold output in fox server for - after this time the url
              may not return the output - default 00:09. -- client-cache="HH:MM", tells client
              browser to cache url page for duration, so repeated url use does not reload from
              server - default 00:00. -- scope="SESSION", fixed value - reserved for future use to
              indicate who can access the url - currently no security restriction if have url. --
              content-type="text/html; charset=UTF-8", fixed value for output encoding mime-type -
              reserved for future use. For the MS Excel methods of CSV and XLS, the type of
              generated cells is derived, by default, from schema mode. If the type of each cell
              cannot be derived from the schema model, the type and format of generated column cells
              may be set explicitly using the "type" and "format-spec" attributes of the
              generate-column specifiers. Otherwise the default generated type of each cell is
              "string".</xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:group ref="fm:generate-cmd-grp"/>
            <xs:attribute name="method" use="required">
              <xs:annotation>
                <xs:documentation>- method="preview", the output is displayed immediately in a
                  pop-up window - feature often used for Print Preview pop-up. -
                  method="storage-location", the output will be saved using a standard fox storage
                  location. Also need attrs: -- storage-location="storage_location_name", the name
                  of the storage-location to use. - method="copy-to", the output (html node) is
                  copied to one or more DOM elements. Also need attrs: -- copy-to-xpath="xpath", the
                  dom nodes to copy html node to (will create dom node when does not exist). -
                  method="url" (formally internal), the output is saved in fox server internally for
                  access later via a URL. Also need attrs: -- url-xpath="xpath", (formally
                  target="xpath") an element which will be assigned with the full URL string needed
                  to access the output. -- expires="HH:MM", duration to hold output in fox server
                  for - after this time the url may not return the output - default 00:09. --
                  client-cache="HH:MM", tells client browser to cache url page for duration, so
                  repeated url use does not reload from server - default 00:00. -- scope="SESSION",
                  fixed value - reserved for future use to indicate who can access the url -
                  currently no security restriction if have url. -- content-type="text/html;
                  charset=UTF-8", fixed value for output encoding mime-type - reserved for future
                  use. </xs:documentation>
              </xs:annotation>
              <xs:simpleType>
                <xs:restriction base="xs:string">
                  <xs:enumeration value="preview"/>
                  <xs:enumeration value="url"/>
                  <xs:enumeration value="storage-location"/>
                  <xs:enumeration value="copy-to"/>
                </xs:restriction>
              </xs:simpleType>
            </xs:attribute>
            <xs:attribute name="state" type="xs:string" use="optional">
              <xs:annotation>
                <xs:documentation>state="state_name", is used to specify the display state to
                  generate display with - when not specified current state is
                  used.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="buffer" type="xs:string" use="optional">
              <xs:annotation>
                <xs:documentation>buffer="state_name|MODULE/buffer_name", is used to specify the
                  starting buffer to generate - when not specified special PAGE is
                  used.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="storage-location" type="fm:entered-string" use="optional">
              <xs:annotation>
                <xs:documentation>- method="storage-location", the output will be saved using a
                  standard fox storage location. Also need attrs: --
                  storage-location="storage_location_name", the name of the storage-location to
                  use.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="copy-to-xpath" type="fm:fox-xpath-type" use="optional">
              <xs:annotation>
                <xs:documentation>- method="copy-to", the output (html node) is copied to one or
                  more DOM elements. Also need attrs: -- copy-to-xpath="xpath", the dom nodes to
                  copy html node to (will create dom node when does not exist).</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="url-xpath" type="fm:fox-xpath-type" use="optional">
              <xs:annotation>
                <xs:documentation>- method="url" (formally internal), the output is saved in fox
                  server internally for access later via a URL. Also need attrs: --
                  url-xpath="xpath", (formally target="xpath") an element which will be assigned
                  with the full URL string needed to access the output.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="expires" type="fm:hours-minutes" use="optional" default="00:09">
              <xs:annotation>
                <xs:documentation>- method="url" (formally internal), the output is saved in fox
                  server internally for access later via a URL. Also need attrs: -- expires="HH:MM",
                  duration to hold output in fox server for - after this time the url may not return
                  the output - default 00:09. </xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="client-cache" type="fm:hours-minutes" use="optional" default="0">
              <xs:annotation>
                <xs:documentation>- method="url" (formally internal), the output is saved in fox
                  server internally for access later via a URL. Also need attrs: --
                  client-cache="HH:MM", tells client browser to cache url page for duration, so
                  repeated url use does not reload from server - default 00:00. </xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="scope" use="optional" fixed="SESSION">
              <xs:annotation>
                <xs:documentation>- method="url" (formally internal), the output is saved in fox
                  server internally for access later via a URL. Also need attrs: -- scope="SESSION",
                  fixed value - reserved for future use to indicate who can access the url -
                  currently no security restriction if have url. </xs:documentation>
              </xs:annotation>
              <xs:simpleType>
                <xs:restriction base="xs:string"/>
              </xs:simpleType>
            </xs:attribute>
            <xs:attribute name="serve-as-attachment" type="fm:fox-xpath-type" use="optional">
              <xs:annotation>
                <xs:documentation>Xpath evaluating to true will cause pop to be severd as an attachment.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="content-type" type="xs:string" use="optional" fixed="text/html; charset=UTF-8">
              <xs:annotation>
                <xs:documentation>- method="url" (formally internal), the output is saved in fox
                  server internally for access later via a URL. Also need attrs: --
                  content-type="text/html; charset=UTF-8", fixed value for output encoding mime-type
                  - reserved for future use. </xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="output-type" use="optional" default="XHTML">
              <xs:simpleType>
                <xs:restriction base="xs:string">
                  <xs:enumeration value="XHTML"/>
                  <xs:enumeration value="CSV"/>
                  <xs:enumeration value="XLS"/>
                  <xs:enumeration value="XML"/>
                </xs:restriction>
              </xs:simpleType>
            </xs:attribute>
            <xs:attribute name="match" type="fm:fox-xpath-type" use="optional"/>
            <xs:attribute name="file-name" type="fm:entered-string">
              <xs:annotation>
                <xs:documentation>A file name for the resultant file; does not need to include a file extension. This can be a static string, or string()ified XPath.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
          </xs:complexType>
        </xs:element>
        <xs:element name="generate-pdf">
          <xs:annotation>
            <xs:documentation>Generate a PDF using buffer content</xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:attribute name="buffer" type="fm:fox-xpath-type" use="required">
              <xs:annotation>
                <xs:documentation>The buffer content to be output in the generated PDF. The buffer must specify a page definition. Stringifyable.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="title" type="fm:fox-xpath-type" use="optional">
              <xs:annotation>
                <xs:documentation>The title added to the generated PDF metadata. Stringifyable.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="subject" type="fm:fox-xpath-type" use="optional">
              <xs:annotation>
                <xs:documentation>The subject added to the generated PDF metadata. Stringifyable.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="author" type="fm:fox-xpath-type" use="optional">
              <xs:annotation>
                <xs:documentation>The author added to the generated PDF metadata. Stringifyable.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="keywords" type="fm:fox-xpath-type" use="optional">
              <xs:annotation>
                <xs:documentation>The keywords added to the generated PDF metadata. Multiple keywords should be entered comma-separated. Stringifyable.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="method" default="download" use="optional">
              <xs:annotation>
                <xs:documentation>The generation method</xs:documentation>
              </xs:annotation>
              <xs:simpleType>
                <xs:restriction base="xs:string">
                  <xs:enumeration value="download"/>
                  <xs:enumeration value="storage-location"/>
                </xs:restriction>
              </xs:simpleType>
            </xs:attribute>
            <xs:attribute name="file-name" type="fm:entered-string" use="optional">
              <xs:annotation>
                <xs:documentation>The file name including extension</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="content-type" type="fm:entered-string" default="application/pdf" use="optional">
              <xs:annotation>
                <xs:documentation>The content type of the generated output</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="serve-as-attachment" type="fm:fox-xpath-type" use="optional">
              <xs:annotation>
                <xs:documentation>XPath evaluating to true will cause the output to be served as an attachment</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="expires" type="fm:hours-minutes" default="00:09" use="optional">
              <xs:annotation>
                <xs:documentation>The time until the saved output expires and can no longer be accessed after generation via URL. Format: "HH:MM"</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="storage-location" type="fm:entered-string" use="optional">
              <xs:annotation>
                <xs:documentation>The destination storage location of the generated document, when generating using method storage-location</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="debug" type="xs:boolean" default="false" use="optional">
              <xs:annotation>
                <xs:documentation>Whether or not to display debug elements in the output</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="ignore-unsupported" type="xs:boolean" default="false" use="optional">
              <xs:annotation>
                <xs:documentation>If true unsupported components and widgets will be ignored instead of throwing an exception when they are encountered. Ignored components and widgets are displayed in the track. Note that ignoring unsupported is not recommended as it causes regression issues if an unsupported component or widget is implemented in the future.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
          </xs:complexType>
        </xs:element>
        <xs:element name="parse-spreadsheet">
          <xs:complexType>
            <xs:group ref="fm:parse-spreadsheet-cmd-grp"/>
            <xs:attribute name="file-storage-location" type="fm:entered-string" use="required"/>
            <xs:attribute name="storage-location" type="fm:entered-string" use="required"/>
            <xs:attribute name="attach" type="fm:fox-xpath-type" use="required"/>
            <xs:attribute name="preserve-empty-cells" use="optional">
              <xs:simpleType>
                <xs:restriction base="fm:entered-string">
                  <xs:enumeration value="true"/>
                  <xs:enumeration value="false"/>
                </xs:restriction>
              </xs:simpleType>
            </xs:attribute>
          </xs:complexType>
        </xs:element>
        <xs:element name="go-to-page">
          <xs:complexType>
            <xs:attribute name="pagination-invoke-name" type="fm:entered-string" use="required"/>
            <xs:attribute name="match" type="fm:entered-string" use="optional"/>
            <xs:attribute name="number" type="fm:fox-xpath-type" use="optional"/>
            <xs:attribute name="out-of-bounds-action" type="fm:entered-string" use="optional"/>
            <xs:attribute name="new-page-size" type="fm:fox-xpath-type" use="optional"/>
          </xs:complexType>
        </xs:element>
        <xs:element name="refresh-pager">
          <xs:complexType>
            <xs:attribute name="pagination-invoke-name" type="fm:entered-string" use="required"/>
            <xs:attribute name="pagination-definition" type="fm:entered-string" use="required"/>
            <xs:attribute name="match" type="fm:fox-xpath-type" use="optional"/>
            <xs:attribute name="xpath" type="fm:fox-xpath-type" use="optional"/>
          </xs:complexType>
        </xs:element>
        <xs:element name="context-localise">
          <xs:complexType>
            <xs:complexContent>
              <xs:extension base="fm:do-block-type">
                <xs:attribute name="name" type="fm:entered-string" use="optional" default="local"/>
                <xs:attribute name="xpath" type="fm:fox-xpath-type" use="optional" default="."/>
                <xs:attribute name="map-set" type="fm:entered-string" use="optional"/>
                <xs:attribute name="map-set-item" type="fm:entered-string" use="optional"/>
                <xs:attribute name="map-set-attach" type="fm:entered-string" use="optional"/>
                <xs:attribute name="storage-location" type="fm:entered-string" use="optional"/>
              </xs:extension>
            </xs:complexContent>
          </xs:complexType>
        </xs:element>
        <xs:element name="context-set">
          <xs:annotation>
            <xs:documentation>scope="state" to set context for current state only - usually the
              case. scope="localised" is used only when inside fm:context-localise or fm:for-each
              blocks.</xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:attribute name="scope" use="required">
              <xs:annotation>
                <xs:documentation>scope="state" to set context for current state only - usually the
                  case. scope="localised" is used only when inside fm:context-localise or
                  fm:for-each blocks.</xs:documentation>
              </xs:annotation>
              <xs:simpleType>
                <xs:restriction base="xs:string">
                  <xs:enumeration value="state"/>
                  <xs:enumeration value="localised"/>
                </xs:restriction>
              </xs:simpleType>
            </xs:attribute>
            <xs:attribute name="name" type="fm:entered-string" use="required"/>
            <xs:attribute name="xpath" type="fm:fox-xpath-type" use="required"/>
          </xs:complexType>
        </xs:element>
        <xs:element name="context-clear">
          <xs:annotation>
            <xs:documentation>scope="state" to clear context for current state only - usually the
              case. scope="localised" is used only when inside fm:context-localise or fm:for-each
              blocks.</xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:attribute name="scope" use="required">
              <xs:annotation>
                <xs:documentation>scope="state" to clear context for current state only - usually
                  the case. scope="localised" is used only when inside fm:context-localise or
                  fm:for-each blocks.</xs:documentation>
              </xs:annotation>
              <xs:simpleType>
                <xs:restriction base="xs:string">
                  <xs:enumeration value="state"/>
                  <xs:enumeration value="localised"/>
                </xs:restriction>
              </xs:simpleType>
            </xs:attribute>
            <xs:attribute name="name" type="fm:entered-string" use="required"/>
          </xs:complexType>
        </xs:element>
        <xs:element name="eval">
          <xs:complexType>
            <xs:attribute name="match" type="fm:fox-xpath-type" use="optional"/>
            <xs:attribute name="expr" use="optional"/>
          </xs:complexType>
        </xs:element>
        <xs:element name="order">
          <xs:complexType>
            <xs:sequence maxOccurs="unbounded">
              <xs:element name="by">
                <xs:complexType>
                  <xs:attribute name="key" type="fm:fox-xpath-type"/>
                  <xs:attribute name="logic" use="optional">
                    <xs:simpleType>
                      <xs:restriction base="xs:string">
                        <xs:enumeration value="blank-number-alpha-ascend"/>
                        <xs:enumeration value="blank-number-alpha-descend"/>
                      </xs:restriction>
                    </xs:simpleType>
                  </xs:attribute>
                </xs:complexType>
              </xs:element>
            </xs:sequence>
            <xs:attribute name="match" type="fm:fox-xpath-type"/>
          </xs:complexType>
        </xs:element>
        <xs:element name="compare">
          <xs:complexType>
            <xs:attribute name="context-one" type="fm:entered-string" use="required"/>
            <xs:attribute name="context-two" type="fm:entered-string" use="required"/>
            <xs:attribute name="version-one" type="fm:entered-string" use="optional"/>
            <xs:attribute name="version-two" type="fm:entered-string" use="required"/>
            <xs:attribute name="context-out" type="fm:entered-string" use="required"/>
            <xs:attribute name="schema-module" type="fm:entered-string" use="optional"/>
            <xs:attribute name="display-style" use="optional">
              <xs:simpleType>
                <xs:restriction base="xs:string">
                  <xs:enumeration value="legacy"/>
                  <xs:enumeration value="hint"/>
                </xs:restriction>
              </xs:simpleType>
            </xs:attribute>
            <xs:attribute name="materialise-mapsets" type="fm:fox-xpath-type" use="optional" default="."/>
          </xs:complexType>
        </xs:element>
        <xs:element name="set-cookie">
          <xs:complexType>
            <xs:attribute name="name" type="fm:fox-xpath-string" use="required">
              <xs:annotation>
                <xs:documentation>Name of the cookie to get a value from.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="value" type="fm:fox-optional-xpath-string" use="optional">
              <xs:annotation>
                <xs:documentation>Value to set the cookie to. If this attribute is empty or omitted the cookie
                  will be unset and removed.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="max-age" type="fm:fox-xpath-number" use="optional">
              <xs:annotation>
                <xs:documentation>The maximum age of the cookie, in seconds. By default this is set to not have a
                  max age and instead timeout with the browser session. While this can be an XPath expression it
                  must yield a numeric value.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="set-path" type="fm:fox-xpath-boolean" use="optional" default="true()">
              <xs:annotation>
                <xs:documentation>Boolean XPath controlling if the Path part of the cookie is set. By default this
                  is true.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="http-only" type="fm:fox-xpath-boolean" use="optional" default="true()">
              <xs:annotation>
                <xs:documentation>Boolean XPath controlling if the cookie is marked as http-only and therefore
                  unmodifiable from javascript. By default this is true.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
          </xs:complexType>
        </xs:element>
        <xs:element name="get-cookie">
          <xs:complexType>
            <xs:attribute name="name" type="fm:fox-xpath-string" use="required">
              <xs:annotation>
                <xs:documentation>Name of the cookie to get a value from.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="result" type="fm:fox-xpath-dom" use="required">
              <xs:annotation>
                <xs:documentation>XPath pointing to a DOM element to store the cookie value in.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
          </xs:complexType>
        </xs:element>
        <xs:group ref="fm:server-side-include-cmd-grp"/>
        <xs:element name="security-scope">
          <xs:annotation>
            <xs:documentation>Chamges the current user system-level and object-level privileges. The
              defaul for system-level privileges is "*" (all); with the default for object-level
              privileges set to "" (none).</xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:attribute name="csv-system-privs" type="xs:string" default="*">
              <xs:annotation>
                <xs:documentation>Comma-Seperated-Values list of system-level
                  privileges.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="uref-xpath" type="fm:fox-xpath-type">
              <xs:annotation>
                <xs:documentation>An XPath expression that identifies the Universal References
                  (URefs) of the items whose object-level priveleges are to be obtained for the
                  current user.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="csv-object-privs" type="xs:string">
              <xs:annotation>
                <xs:documentation>Comma-Seperated-Values list of object-level privileges to check
                  against the urefs identified by the uref-xpath for the current
                  user.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="csv-uref-types" type="xs:string">
              <xs:annotation>
                <xs:documentation>Comma-Seperated-Values list of Universal Reference Types of
                  objects whose object-level priveleges are to be determined for the current
                  user.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
          </xs:complexType>
        </xs:element>
        <xs:element name="user-login">
          <xs:annotation>
            <xs:documentation>Logs in a portal user. The current FOX session is then owned by the
              specified user.</xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:attribute name="wua-login-id" type="fm:fox-xpath-type" use="required">
              <xs:annotation>
                <xs:documentation>The Web User Account Login ID of the user to log
                  in.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="password" type="fm:fox-xpath-type" use="required">
              <xs:annotation>
                <xs:documentation>The password for the user account specified.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="status-code" type="fm:fox-xpath-type" use="optional"/>
            <xs:attribute name="status-message" type="fm:fox-xpath-type" use="optional"/>
            <xs:attribute name="authentication-method" use="optional">
              <xs:simpleType>
                <xs:restriction base="xs:string">
                  <xs:enumeration value="LDAP"/>
                </xs:restriction>
              </xs:simpleType>
            </xs:attribute>
            <xs:attribute name="authentication-domain" use="optional"/>
            <xs:attribute name="params-xml" type="fm:fox-xpath-type" use="optional">
              <xs:annotation>
                <xs:documentation>XPath to parameter XML that will be passed into authentication.create_session for implementation specific use</xs:documentation>
              </xs:annotation>
            </xs:attribute>
          </xs:complexType>
        </xs:element>
        <xs:element name="resume-login">
          <xs:annotation>
            <xs:documentation>Creates a session for a portal user attempting two factor authentication. The current FOX session is then owned by the specified user.</xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:attribute name="hash-code" type="fm:fox-xpath-type" use="required">
              <xs:annotation>
                <xs:documentation>The hash code created on the initial log in attempt.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="status-code" type="fm:fox-xpath-type" use="optional">
              <xs:annotation>
                <xs:documentation>Passes back the status of the login attempt (e.g. VALID,SUSPENDED,TFA_TOKEN_TIMEOUT). Note if this is not specified, the resume fails and a hard error occurs.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="status-message" type="fm:fox-xpath-type" use="optional">
              <xs:annotation>
                <xs:documentation>Passes back the message which is relevant to the status code. Note if this is not specified, the resume fails and a hard error occurs.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
          </xs:complexType>
        </xs:element>
        <xs:element name="user-logout">
          <xs:annotation>
            <xs:documentation>Logs out the current user from the portal. The user is returned to the
              Portal Home page.</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="saml-response">
          <xs:annotation>
            <xs:documentation>Return a SAML Response to the recipient with optional signing, attributes and conditions.</xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:attribute name="relay-state" type="fm:fox-optional-xpath-string" use="optional">
              <xs:annotation>
                <xs:documentation>Data to post to the recipient in a RelayState parameters, this should have been posted
                  to FOX from the Service Provider when it made the auth request.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="recipient" type="fm:fox-xpath-string" use="required">
              <xs:annotation>
                <xs:documentation>The URL of the service provider to post the SAML Response back to.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="audience" type="fm:fox-xpath-string" use="required">
              <xs:annotation>
                <xs:documentation>The root URL of the service provider.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="timeout" type="fm:fox-xpath-number" use="optional">
              <xs:annotation>
                <xs:documentation>Milliseconds this response will be valid for. Defaults to 1 minute.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="digital-certificate-name" type="fm:fox-optional-xpath-string" use="optional">
              <xs:annotation>
                <xs:documentation>Name of an X509 certificate in DECMGR.DIGITAL_CERTIFICATES to use for signing.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="sign-response" type="fm:fox-xpath-boolean" use="optional" default=".">
              <xs:annotation>
                <xs:documentation>Boolean XPath to sign the SAML Response.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="sign-assertion" type="fm:fox-xpath-boolean" use="optional" default=".">
              <xs:annotation>
                <xs:documentation>Boolean XPath to sign the assertion part of the SAML Response.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="assertion-attributes" type="fm:fox-xpath-dom" use="required">
              <xs:annotation>
                <xs:documentation>XPath to DOM containing attributes the SAML Response is asserting as valid. DOM should
                  contain a series of elements where element names will be used as attribute names and text content will
                  be used as attribute value.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
          </xs:complexType>
        </xs:element>
        <xs:element name="state-push">
          <xs:annotation>
            <xs:documentation>
              State transition command. Use this command to move between states on your bunsess workflow diagram.

              This behaviour of this command is determined by the 'action' attribute:

              push:
              Adds a new state to the state-call stack.
              Note that any previous states still exist on the stack-call stack. Any previous state will be returned to when the state added is subsequently 'popped' off the stack.

              pop:
              Pops off the state at the top of the state-call stack.

              replace:
              Replaces the topmost state, on the state-call stack, with the specified state.
              Can also be used to replace all states on the state-call stack with the state specified.
            </xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:attribute name="name" type="xs:string" use="optional"/>
            <xs:attribute name="attach" type="fm:fox-xpath-type" use="optional"/>
            <xs:attribute name="all" type="xs:boolean" use="optional" default="false"/>
          </xs:complexType>
        </xs:element>
        <xs:element name="state-replace">
          <xs:annotation>
            <xs:documentation>
              State transition command. Use this command to move between states on your bunsess workflow diagram.

              This behaviour of this command is determined by the 'action' attribute:

              push:
              Adds a new state to the state-call stack.
              Note that any previous states still exist on the stack-call stack. Any previous state will be returned to when the state added is subsequently 'popped' off the stack.

              pop:
              Pops off the state at the top of the state-call stack.

              replace:
              Replaces the topmost state, on the state-call stack, with the specified state.
              Can also be used to replace all states on the state-call stack with the state specified.
            </xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:attribute name="name" type="xs:string" use="optional"/>
            <xs:attribute name="attach" type="fm:fox-xpath-type" use="optional"/>
            <xs:attribute name="all" type="xs:boolean" use="optional" default="false"/>
          </xs:complexType>
        </xs:element>
        <xs:element name="state-strict-pop">
          <xs:annotation>
            <xs:documentation>
              State transition command. Use this command to move between states on your bunsess workflow diagram.

              This behaviour of this command is determined by the 'action' attribute:

              push:
              Adds a new state to the state-call stack.
              Note that any previous states still exist on the stack-call stack. Any previous state will be returned to when the state added is subsequently 'popped' off the stack.

              pop:
              Pops off the state at the top of the state-call stack.

              replace:
              Replaces the topmost state, on the state-call stack, with the specified state.
              Can also be used to replace all states on the state-call stack with the state specified.
            </xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:attribute name="name" type="xs:string" use="optional"/>
            <xs:attribute name="attach" type="fm:fox-xpath-type" use="optional"/>
            <xs:attribute name="all" type="xs:boolean" use="optional" default="false"/>
          </xs:complexType>
        </xs:element>
        <xs:element name="post-dom">
          <xs:complexType>
            <xs:attribute name="context-label" type="xs:string" use="required"/>
          </xs:complexType>
        </xs:element>
        <xs:element name="generate-spreadsheet">
          <xs:complexType>
            <xs:attribute name="name" type="xs:string"/>
            <xs:attribute name="method" type="fm:generate-spreadsheet-type"/>
            <xs:attribute name="file-name" type="xs:string"/>
            <xs:attribute name="storage-location-name" type="xs:string"/>
          </xs:complexType>
        </xs:element>
        <xs:element name="switch-tab">
          <xs:complexType>
            <xs:attribute name="tabGroupName" type="fm:entered-string" use="required"/>
            <xs:attribute default="." name="tabGroupAttach" type="fm:entered-string" use="optional"/>
            <xs:attribute name="tabKey" type="fm:entered-string"/>
            <xs:attribute name="tabDOM" type="fm:entered-string"/>
          </xs:complexType>
        </xs:element>
        <xs:element name="set-variable">
          <xs:annotation>
            <xs:documentation>Sets a variable which can be referred to in subsequent XPath expression evaluation using $variableName syntax.
              The variable is scoped to the current module call. Use the "expr" attribute if the value should be the result of an XPath expression
              (including a non-string item such as an xs:date), or the "textValue" attribute for a fixed string value.</xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:attribute name="name" type="fm:entered-string" use="required">
              <xs:annotation>
                <xs:documentation>Name of the variable to set. This must be a valid NCName.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="expr" type="fm:entered-string" use="optional">
              <xs:annotation>
                <xs:documentation>XPath expression to evaluate and use as the value for the variable. This may be a sequence containing nodes
                  of any type. Variables will resolve to copies of the items selected by this expression, not the original items. Avoid setting
                  large sequences as variable values as this will cause a serialisation overhead.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="textValue" type="fm:entered-string" use="optional">
              <xs:annotation>
                <xs:documentation>Fixed text to set the variable's value to. The item type of the variable will be a string. To set to
                  other item types, use the expr attribute and qualify the item type as a constructor, e.g. "xs:date('2015-01-01')".</xs:documentation>
              </xs:annotation>
            </xs:attribute>
          </xs:complexType>
        </xs:element>
        <xs:element name="clear-variable">
          <xs:annotation>
            <xs:documentation>Clears an XPath variable which was previously set with fm:set-variable. If the variable was not already set, no action is taken.</xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:attribute name="name" type="fm:entered-string" use="required">
              <xs:annotation>
                <xs:documentation>Name of the variable to clear.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
          </xs:complexType>
        </xs:element>
        <xs:element name="load-document-template">
          <xs:annotation>
            <xs:documentation>Loads document template metadata. This command requires the Document Generation plugin to be installed.</xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:attribute name="doc-template-target-metadata" type="fm:entered-string" use="required">
              <xs:annotation>
                <xs:documentation>Location to create the document template target metadata.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="doc-template-name" type="fm:entered-string" use="required">
              <xs:annotation>
                <xs:documentation>Name of the document template to load.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
          </xs:complexType>
        </xs:element>
        <xs:element name="preview-document-template">
          <xs:annotation>
            <xs:documentation>Previews the result of running document generation against a document template. This command requires the Document Generation plugin to be installed.</xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:attribute name="doc-template-target-metadata" type="fm:entered-string" use="required">
              <xs:annotation>
                <xs:documentation>Location of the document template target metadata, as loaded by fm:load-document-template.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="doc-template-name" type="fm:entered-string" use="required">
              <xs:annotation>
                <xs:documentation>Name of document template to generate.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="fo-target" use="optional">
              <xs:annotation>
                <xs:documentation>If specified, the FO used to generate the preview document will be written to this node.</xs:documentation>
              </xs:annotation>
              <xs:simpleType>
                <xs:restriction base="fm:entered-string">
                  <xs:minLength value="1"/>
                </xs:restriction>
              </xs:simpleType>
            </xs:attribute>
            <xs:attribute name="warnings-target" use="optional">
              <xs:annotation>
                <xs:documentation>If specified, any warning text encountered while generating the preview document will be written to this node.</xs:documentation>
              </xs:annotation>
              <xs:simpleType>
                <xs:restriction base="fm:entered-string">
                  <xs:minLength value="1"/>
                </xs:restriction>
              </xs:simpleType>
            </xs:attribute>
          </xs:complexType>
        </xs:element>
        <xs:element name="show-popover">
          <xs:annotation>
            <xs:documentation>Shows a modal popover on the screen, which is rendered in front of all other content and blocks the user from clicking behind it.</xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:attribute name="buffer" type="fm:entered-string" use="required">
              <xs:annotation>
                <xs:documentation>The name of the buffer containing the content for the modal popover.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="bufferAttach" type="fm:entered-string">
              <xs:annotation>
                <xs:documentation>Attach point to use when evaluating the popover buffer. The default is the current state attach point if not specified.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="title" type="fm:entered-string">
              <xs:annotation>
                <xs:documentation>The title of the modal popover, which appears before the content buffer. If not specified, no title is displayed.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="size">
              <xs:annotation>
                <xs:documentation>Specify the width of the popover. If not specified, the default is 'regular'.</xs:documentation>
              </xs:annotation>
              <xs:simpleType>
                <xs:restriction base="xs:string">
                  <xs:enumeration value="regular"/>
                  <xs:enumeration value="large"/>
                  <xs:enumeration value="small"/>
                  <xs:enumeration value="dynamic"/>
                </xs:restriction>
              </xs:simpleType>
            </xs:attribute>
            <xs:attribute name="class" type="fm:entered-string">
              <xs:annotation>
                <xs:documentation>Additional CSS class(es) to set on the popover's containing element.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
          </xs:complexType>
        </xs:element>
        <xs:element name="close-popover">
          <xs:annotation>
            <xs:documentation>Closes the active modal popover (as created by fm:show-popover). If no modal popover is currently displayed, this command does nothing.</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="flash">
          <xs:annotation>
            <xs:documentation>Shows a non-modal, dismissable message at the top of the screen.</xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:attribute name="message" type="fm:fox-xpath-string" use="required">
              <xs:annotation>
                <xs:documentation>Message to display. Fixed or unescaped strings may contain HTML tags.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="type" type="fox:notification-display-type" default="info">
              <xs:annotation>
                <xs:documentation>Built-in styling rules to apply to the flash message.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="class" type="fm:fox-xpath-string" use="optional">
              <xs:annotation>
                <xs:documentation>Additional CSS class(es) to set on the flash's container element.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
          </xs:complexType>
        </xs:element>
        <xs:element name="odf-metadata-read">
          <xs:annotation>
            <xs:documentation>Read metadata fields from ODF files into the DOM</xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:attribute name="file-storage-location" type="fm:entered-string" use="required">
              <xs:annotation>
                <xs:documentation>File storage location to take an ODF file from for metadata reading</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="metadata-output" type="fm:fox-xpath-type" use="required">
              <xs:annotation>
                <xs:documentation>XPath pointing to a DOM where metadata information will be put</xs:documentation>
              </xs:annotation>
            </xs:attribute>
          </xs:complexType>
        </xs:element>
        <xs:element name="odf-process">
          <xs:annotation>
            <xs:documentation>Process an ODF file: setting metadata, mail-merging fields, converting to other formats</xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:attribute name="file-storage-location" type="fm:entered-string" use="required">
              <xs:annotation>
                <xs:documentation>File storage location to take an ODF file from for processing</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="destination-storage-location" type="fm:entered-string" use="required">
              <xs:annotation>
                <xs:documentation>File storage location to write the processed ODF file to</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="output-format" default="ODT" use="optional">
              <xs:annotation>
                <xs:documentation>Optionally convert the ODF file to another output format</xs:documentation>
              </xs:annotation>
              <xs:simpleType>
                <xs:restriction base="fm:entered-string">
                  <xs:enumeration value="ODT"/>
                  <xs:enumeration value="PDF"/>
                  <xs:enumeration value="XHTML"/>
                </xs:restriction>
              </xs:simpleType>
            </xs:attribute>
            <xs:attribute name="metadata" type="fm:fox-xpath-type" use="optional">
              <xs:annotation>
                <xs:documentation>XPath pointing to a metadata element in the DOM which conforms to the ODF metadata schema for the ODF plugin defining metadata values to set</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="fields" type="fm:fox-xpath-type" use="optional">
              <xs:annotation>
                <xs:documentation>XPath pointing to a fields element in the DOM defining field names and values to merge in</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="status" type="fm:fox-xpath-type" use="optional">
              <xs:annotation>
                <xs:documentation>XPath pointing to a DOM where any errors from the ODF processing will be written</xs:documentation>
              </xs:annotation>
            </xs:attribute>
          </xs:complexType>
        </xs:element>
      </xs:choice>
      <xs:choice minOccurs="0">
        <xs:element name="call-module">
          <xs:annotation>
            <xs:documentation>Calls a theme in the same or another module, modally or modelessly. A
              modal call shares the original browser window. A modeless call launches a new browser
              window that is a child of the current browser. A called module must exit a call with
              the exit-module command.</xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:attribute name="module" type="xs:string" use="required">
              <xs:annotation>
                <xs:documentation>The name of the module, within the specified application, to call.
                  Defaults to the current module.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="theme" type="xs:string" use="required">
              <xs:annotation>
                <xs:documentation>The name of the theme. within the specified application and
                  module, to call.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="type" use="required">
              <xs:annotation>
                <xs:documentation>The type of module call. Must be one of: modal - the existing
                  browser window will be used to display the call dialog modeless - a new window (a
                  child of the existing browser) will be used to display the call dialog. See
                  windowName and windowProperties attributes.</xs:documentation>
              </xs:annotation>
              <xs:simpleType>
                <xs:restriction base="xs:string">
                  <xs:enumeration value="modal"/>
                  <xs:enumeration value="modeless"/>
                  <xs:enumeration value="modeless-orphan-same-session"/>
                  <xs:enumeration value="modeless-orphan-new-session"/>
                  <xs:enumeration value="modal-return-to-first-or-replace-all-cancel-callbacks"/>
                  <xs:enumeration value="modal-replace-all-cancel-callbacks"/>
                  <xs:enumeration value="modal-replace-this-cancel-callbacks"/>
                  <xs:enumeration value="modal-replace-this-caller-callbacks-now-then-cancel-callbacks"/>
                  <xs:enumeration value="modal-replace-this-preserve-caller-callbacks-for-exit"/>
                </xs:restriction>
              </xs:simpleType>
            </xs:attribute>
            <xs:attribute name="app" type="xs:string" use="optional">
              <xs:annotation>
                <xs:documentation>The application mnemonic of the application whose module is to be
                  called. Defaults to the current application.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="params" type="xs:string" use="optional">
              <xs:annotation>
                <xs:documentation>An xpath expression that returns a node list which are the
                  parameters of the module call. These parameters are passed, by value, to the
                  called module.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="literalParams" type="xs:string" use="optional">
              <xs:annotation>
                <xs:documentation>A comma-separated list of 'name=value' pairs that are additional
                  parameters to the module call. Example: literalParams="type=P,no=6000" ** NOTE:
                  This is an in-progress solution and may change in the future. </xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="callback-action" type="xs:string" use="optional">
              <xs:annotation>
                <xs:documentation>The action to be called, in the calling module, upon exit of the
                  called module.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="returnTargets" type="xs:string" use="optional">
              <xs:annotation>
                <xs:documentation>An xpath expression that returns a node list that identifies one
                  or more nodes in the calling modules data document. Any return values, from the
                  called module, are subsequently copied to these nodes on return from the module
                  call.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="windowName" type="xs:string" use="optional">
              <xs:annotation>
                <xs:documentation>The name of the window, if required by the fox developer. If
                  specified, any child popup window will have the specified name. If a child with
                  the specifed name already exists, the same window will be reused. This give the
                  fox developer control over the number and reuse of child popups. If not specified,
                  a unique name is generated for any child popup that results from the module call.
                  This guarantees that a new child window will always appear for the call, if
                  modeless.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="windowProperties" type="xs:string" use="optional">
              <xs:annotation>
                <xs:documentation>Only applicable to modeless module calls. A comma-separated list
                  of properties of the child window that will display the module call dialog. These
                  are javascript properties (see javascript reference manual on 'window' object)
                  that specifiy the window geometry etc. etc. Example:
                  windowProperties="width=200,height=600,resizable,status,toolbar,menubar" ** NOTE:
                  This is an in-progress solution and may change in the future.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
          </xs:complexType>
        </xs:element>
        <xs:element name="exit-module">
          <xs:annotation>
            <xs:documentation>Exits the current module call. This command should be used to
              physically end a module call that maps to a logical end to some business process or
              procedure.</xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:attribute name="type" use="optional">
              <xs:simpleType>
                <xs:restriction base="xs:string">
                  <xs:enumeration value="exit-this-preserve-callbacks"/>
                  <xs:enumeration value="exit-this-cancel-callbacks"/>
                  <xs:enumeration value="exit-all-cancel-callbacks"/>
                </xs:restriction>
              </xs:simpleType>
            </xs:attribute>
            <xs:attribute name="uri" type="xs:string" use="optional"/>
          </xs:complexType>
        </xs:element>
        <xs:element name="state">
          <xs:annotation>
            <xs:documentation>
              State transition command. Use this command to move between states on your bunsess workflow diagram.

              This behaviour of this command is determined by the 'action' attribute:

              push:
              Adds a new state to the state-call stack.
              Note that any previous states still exist on the stack-call stack. Any previous state will be returned to when the state added is subsequently 'popped' off the stack.

              pop:
              Pops off the state at the top of the state-call stack.

              replace:
              Replaces the topmost state, on the state-call stack, with the specified state.
              Can also be used to replace all states on the state-call stack with the state specified.
            </xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:attribute name="action" use="required">
              <xs:simpleType>
                <xs:restriction base="fm:entered-string">
                  <xs:enumeration value="pop"/>
                  <xs:enumeration value="push"/>
                  <xs:enumeration value="replace"/>
                </xs:restriction>
              </xs:simpleType>
            </xs:attribute>
            <xs:attribute name="name" type="xs:string" use="optional"/>
            <xs:attribute name="attach" type="fm:fox-xpath-type" use="optional"/>
            <xs:attribute name="all" type="xs:boolean" use="optional" default="false"/>
          </xs:complexType>
        </xs:element>
        <xs:element name="state-pop">
          <xs:annotation>
            <xs:documentation>
              State transition command. Use this command to move between states on your bunsess workflow diagram.

              This behaviour of this command is determined by the 'action' attribute:

              push:
              Adds a new state to the state-call stack.
              Note that any previous states still exist on the stack-call stack. Any previous state will be returned to when the state added is subsequently 'popped' off the stack.

              pop:
              Pops off the state at the top of the state-call stack.

              replace:
              Replaces the topmost state, on the state-call stack, with the specified state.
              Can also be used to replace all states on the state-call stack with the state specified.
            </xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:attribute name="name" type="xs:string" use="optional"/>
            <xs:attribute name="attach" type="fm:fox-xpath-type" use="optional"/>
            <xs:attribute name="all" type="xs:boolean" use="optional" default="false"/>
          </xs:complexType>
        </xs:element>
      </xs:choice>
    </xs:sequence>
  </xs:complexType>
  <xs:simpleType name="generate-spreadsheet-type">
    <xs:restriction base="xs:string">
      <xs:enumeration value="download"/>
      <xs:enumeration value="storage-location"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="action-types">
    <xs:annotation>
      <xs:documentation>Allows the enumerated action types</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="client-side"/>
      <xs:enumeration value="server-side"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="overload-types">
    <xs:annotation>
      <xs:documentation>Determines whether module overloading is allowed during library merging</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="allowed"/>
      <xs:enumeration value="not-allowed"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:complexType name="presentation-type">
    <xs:sequence>
      <xs:element name="implicated-data-definition-list" minOccurs="0">
        <xs:annotation>
          <xs:documentation>List data-definitions you wish to be accessible via Javascript when this state is used</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="data-definition">
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:attribute name="match" type="fm:fox-xpath-type" default="." use="optional">
                      <xs:annotation>
                        <xs:documentation>The path of context nodes to process</xs:documentation>
                      </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="foxDataKey" type="fm:fox-xpath-type" use="optional">
                      <xs:annotation>
                        <xs:documentation>If your match attribute points to a repeating element this attribute is mandatory and should be an XPath that will resolve to a unique key for each matched node</xs:documentation>
                      </xs:annotation>
                    </xs:attribute>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
      <xs:element name="set-page" minOccurs="0">
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="html-or-fox-html-tags-type">
              <xs:attribute name="stub-overload"/>
              <xs:attribute name="build-only"/>
              <xs:attribute name="document-type" use="optional" default="HTML5">
                <xs:simpleType>
                  <xs:restriction base="xs:string">
                    <xs:enumeration value="HTML5"/>
                    <xs:enumeration value="HTML4_TRANSITIONAL"/>
                    <xs:enumeration value="HTML4_STRICT"/>
                    <xs:enumeration value="XHTML1_TRANSITIONAL"/>
                    <xs:enumeration value="XHTML1_STRICT"/>
                    <xs:enumeration value="NONE"/>
                  </xs:restriction>
                </xs:simpleType>
              </xs:attribute>
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="set-buffer" minOccurs="0" maxOccurs="unbounded">
        <xs:complexType mixed="true">
          <xs:complexContent mixed="true">
            <xs:extension base="html-or-fox-html-tags-type">
              <xs:attribute name="name" type="fm:entered-string"/>
              <xs:attribute name="stub-overload"/>
              <xs:attribute name="build-only"/>
              <xs:attribute name="region-title"/>
              <xs:attribute name="region-order"/>
              <xs:attribute name="preserve-comments" use="optional">
                <xs:simpleType>
                  <xs:restriction base="xs:string">
                    <xs:enumeration value="true"/>
                    <xs:enumeration value="false"/>
                  </xs:restriction>
                </xs:simpleType>
              </xs:attribute>
              <xs:attribute name="page-definition-name" type="fm:entered-string">
                <xs:annotation>
                  <xs:documentation>The page definition that specifies the attributes to use when generating PDF pages of the buffer content. When a buffer specifying a page definition is encountered during PDF generation, a new page will be started using the attributes of the page definition when the buffer content is output. If no content exists, the new page will not be started (i.e. there will not be a blank page), but the current page if one exists will be ended. This allows a page break to be inserted by including an empty buffer that defines a page definition.</xs:documentation>
                </xs:annotation>
              </xs:attribute>
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="display-attr-list" minOccurs="0">
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="fm:display-attr-list-type">
              <xs:attribute name="stub-overload"/>
              <xs:attribute name="build-only"/>
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="action-list-type">
    <xs:sequence>
      <xs:element name="action" minOccurs="0" maxOccurs="unbounded">
        <xs:complexType>
          <xs:sequence>
            <xs:element maxOccurs="1" minOccurs="0" name="requires">
              <xs:complexType>
                <xs:sequence>
                  <xs:element maxOccurs="unbounded" minOccurs="0" name="context">
                    <xs:complexType>
                      <xs:attribute name="name" type="fm:entered-string" use="required"/>
                    </xs:complexType>
                  </xs:element>
                  <xs:element maxOccurs="unbounded" minOccurs="0" name="variable">
                    <xs:complexType>
                      <xs:attribute name="name" type="fm:entered-string" use="required"/>
                    </xs:complexType>
                  </xs:element>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
            <xs:element name="do" type="fm:do-block-type"/>
            <xs:element name="documentation" type="fm:documentation" minOccurs="0"/>
          </xs:sequence>
          <xs:attribute name="name" type="fm:slashless-entered-string" use="required"/>
          <xs:attribute name="no-apply" type="fm:yn-flag"/>
          <xs:attribute name="type" type="fm:action-types"/>
          <xs:attribute name="stub-overload"/>
          <xs:attribute name="assertion" fixed=".">
            <xs:annotation>
              <xs:documentation>Marks this action as an assertion action which will be executed by the assertion runner. The module must be marked up as an assertion module - see fm:assertion-module in the fm:control section.</xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="build-only"/>
          <xs:attributeGroup ref="fox:zzz-action-attr-grp"/>
          <xs:anyAttribute namespace="##other" processContents="skip"/>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="xpath-list-type">
    <xs:sequence>
      <xs:element name="xpath" maxOccurs="unbounded">
        <xs:complexType>
          <xs:attribute name="name" type="fm:entered-string" use="required"/>
          <xs:attribute name="value" type="fm:entered-string" use="required"/>
          <xs:attribute name="overload" type="fm:overload-types"/>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="storage-location-type">
    <xs:annotation>
      <xs:documentation/>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="cache-key" minOccurs="0">
        <xs:complexType>
          <xs:sequence>
            <xs:group ref="fm:using-clause-grp"/>
          </xs:sequence>
          <xs:attribute name="string" type="xs:string" use="optional"/>
          <xs:attribute fixed="unique" name="type">
            <xs:annotation>
              <xs:documentation>Shortcut markup for defining a unique cache key. The FOX engine will generate a unique cache key definition for you if you specify this attribute - there is no need to define any using clauses.</xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>
      <xs:element minOccurs="0" name="context-label" type="fm:entered-string">
        <xs:annotation>
          <xs:documentation>If this storage location defines a DOM, specify the context label to be used to refer to the DOM here. A default of "root" is assumed if the current entry theme only specifies one storage location.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="new-document">
        <xs:complexType>
          <xs:sequence>
            <xs:element name="root-element" type="fm:entered-string"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
      <xs:element name="database" minOccurs="0">
        <xs:complexType>
          <xs:sequence>
            <xs:element name="query" minOccurs="0">
              <xs:complexType>
                <xs:sequence>
                  <xs:element name="sql" type="fm:entered-string"/>
                  <xs:element name="read-only-sql" type="fm:entered-string" minOccurs="0"/>
                  <xs:group ref="fm:using-clause-grp"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
            <xs:element name="insert" minOccurs="0">
              <xs:complexType>
                <xs:sequence>
                  <xs:element name="sql" type="fm:entered-string"/>
                  <xs:group ref="fm:using-clause-grp"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
            <xs:element name="update" minOccurs="0">
              <xs:complexType>
                <xs:sequence>
                  <xs:element name="sql" type="fm:entered-string"/>
                  <xs:group ref="fm:using-clause-grp"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
      <xs:element name="validation" minOccurs="0" type="fm:do-block-type">
        <xs:annotation>
          <xs:documentation>This fm:do block is executed before the storage location's DOM is opened for editing and before any posted values are applied to it. Callstack transformations such as a module call or exit module which occur in this block will be executed immediately, preventing the DOM from being modified. Use this to prevent unauthorised DOM modifications in the case that some external condition is met (for instance, the application status has changed and moved to a read-only stage).</xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="file-storage-location-type">
    <xs:annotation>
      <xs:documentation>Storage location sub-class for files.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="cache-key">
        <xs:complexType>
          <xs:sequence>
            <xs:group ref="fm:using-clause-grp"/>
          </xs:sequence>
          <xs:attribute name="string" type="xs:string" use="required"/>
        </xs:complexType>
      </xs:element>
      <xs:sequence>
        <xs:element name="database" minOccurs="0">
          <xs:complexType>
            <xs:sequence>
              <xs:element name="query">
                <xs:complexType>
                  <xs:sequence>
                    <xs:element name="sql" type="fm:entered-string"/>
                    <xs:group ref="fm:using-clause-grp"/>
                  </xs:sequence>
                </xs:complexType>
              </xs:element>
              <xs:element name="insert" minOccurs="0">
                <xs:complexType>
                  <xs:sequence>
                    <xs:element name="sql" type="fm:entered-string"/>
                    <xs:group ref="fm:using-clause-grp"/>
                  </xs:sequence>
                </xs:complexType>
              </xs:element>
              <xs:element name="update" minOccurs="0">
                <xs:complexType>
                  <xs:sequence>
                    <xs:element name="sql" type="fm:entered-string"/>
                    <xs:group ref="fm:using-clause-grp"/>
                  </xs:sequence>
                </xs:complexType>
              </xs:element>
              <xs:element name="delete" minOccurs="0">
                <xs:complexType>
                  <xs:sequence>
                    <xs:element name="sql" type="fm:entered-string"/>
                    <xs:group ref="fm:using-clause-grp"/>
                  </xs:sequence>
                </xs:complexType>
              </xs:element>
            </xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name="api" minOccurs="0">
          <xs:complexType>
            <xs:sequence>
              <xs:element name="statement">
                <xs:annotation>
                  <xs:documentation>A code/script block with bind variables. The code block might be
                    a PL/SQL anonymous block or Java.</xs:documentation>
                </xs:annotation>
              </xs:element>
              <xs:element name="using" minOccurs="0" maxOccurs="unbounded">
                <xs:complexType>
                  <xs:simpleContent>
                    <xs:extension base="xs:string">
                      <xs:attribute name="using-type" use="optional">
                        <xs:simpleType>
                          <xs:restriction base="fm:entered-string">
                            <xs:enumeration value="XPATH"/>
                            <xs:enumeration value="UNIQUE"/>
                            <xs:enumeration value="STATIC"/>
                            <xs:enumeration value="DATA-XMLTYPE"/>
                            <xs:enumeration value="DATA-CLOB"/>
                            <xs:enumeration value="DATA-BLOB"/>
                            <xs:enumeration value="FILE-METADATA-XMLTYPE"/>
                          </xs:restriction>
                        </xs:simpleType>
                      </xs:attribute>
                    </xs:extension>
                  </xs:simpleContent>
                </xs:complexType>
              </xs:element>
            </xs:sequence>
            <xs:attribute name="language" default="PL/SQL">
              <xs:annotation>
                <xs:documentation>Specifies the language of the api call. Initially only PL/SQL is
                  supported</xs:documentation>
              </xs:annotation>
              <xs:simpleType>
                <xs:restriction base="fm:entered-string">
                  <xs:enumeration value="PL/SQL"/>
                  <xs:enumeration value="SOAP"/>
                  <xs:enumeration value="JAVA"/>
                </xs:restriction>
              </xs:simpleType>
            </xs:attribute>
          </xs:complexType>
        </xs:element>
      </xs:sequence>
    </xs:sequence>
  </xs:complexType>
  <xs:group name="db-interface-grp">
    <xs:sequence>
      <xs:element name="db-interface" minOccurs="0" maxOccurs="unbounded">
        <xs:annotation>
          <xs:documentation>Defrines multiple SQL queries tags to populate DOM. Up to 1 table tag to
            populate database from DOM and multiple API calls to make native code callouts if
            required</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="table" minOccurs="0">
              <xs:annotation>
                <xs:documentation>Provides lock and other processing to populate the database from
                  DOM.</xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:element name="map-path">
                    <xs:annotation>
                      <xs:documentation>Defines the DOM source for the table tag. </xs:documentation>
                      <xs:documentation>Defines the DOM target for all select tags and/or Defines
                        the DOM source for the table tag. Mandatory for non-singleton selects or if
                        a table tag is present.</xs:documentation>
                    </xs:annotation>
                    <xs:complexType>
                      <xs:attribute name="match" type="xs:string">
                        <xs:annotation>
                          <xs:documentation>Specifies the pathname of context nodes to process in
                            XPath format. The directory portion of this pathname must only navigate
                            through single instance nodes. The base name part can have multiple node
                            instances, all of which will be processed.</xs:documentation>
                        </xs:annotation>
                      </xs:attribute>
                    </xs:complexType>
                  </xs:element>
                  <xs:element name="primary">
                    <xs:complexType>
                      <xs:sequence>
                        <xs:element name="key" maxOccurs="unbounded">
                          <xs:annotation>
                            <xs:documentation>The Primary or composite part of the primary key. This
                              refers to the database column name</xs:documentation>
                          </xs:annotation>
                        </xs:element>
                      </xs:sequence>
                    </xs:complexType>
                  </xs:element>
                  <xs:element name="using" minOccurs="0" maxOccurs="unbounded">
                    <xs:annotation>
                      <xs:documentation>Overrides the default sql to dom data conversion rules
                      </xs:documentation>
                    </xs:annotation>
                    <xs:complexType>
                      <xs:simpleContent>
                        <xs:extension base="fm:entered-string">
                          <xs:attribute name="datadom-type">
                            <xs:annotation>
                              <xs:documentation>The FOX dom type that this attribute maps to. If not
                                entered fox will attempt to resolve the type at runtime (usually
                                string) </xs:documentation>
                            </xs:annotation>
                            <xs:simpleType>
                              <xs:restriction base="fm:entered-string">
                                <xs:enumeration value="string">
                                  <xs:annotation>
                                    <xs:documentation>this is the default and should normally be
                                      specified. It is put here for descriptive purposes
                                      only</xs:documentation>
                                  </xs:annotation>
                                </xs:enumeration>
                                <xs:enumeration value="dom">
                                  <xs:annotation>
                                    <xs:documentation>This will operate on the node and all sub
                                      nodes. The equivalent sql-data must be able to be cast as an
                                      xml type.</xs:documentation>
                                  </xs:annotation>
                                </xs:enumeration>
                                <xs:enumeration value="date">
                                  <xs:annotation>
                                    <xs:documentation>CCYYMMDD</xs:documentation>
                                  </xs:annotation>
                                </xs:enumeration>
                                <xs:enumeration value="datetime">
                                  <xs:annotation>
                                    <xs:documentation>CCYYMMDDThh:mm:ss</xs:documentation>
                                  </xs:annotation>
                                </xs:enumeration>
                                <xs:enumeration value="time">
                                  <xs:annotation>
                                    <xs:documentation>hh:mm:ss</xs:documentation>
                                  </xs:annotation>
                                </xs:enumeration>
                              </xs:restriction>
                            </xs:simpleType>
                          </xs:attribute>
                          <xs:attribute name="sql-type">
                            <xs:annotation>
                              <xs:documentation>The sql datatype in the database. If not entered
                                then FOX will try to determine the datatype at
                                runtime</xs:documentation>
                            </xs:annotation>
                            <xs:simpleType>
                              <xs:restriction base="fm:entered-string">
                                <xs:enumeration value="varchar">
                                  <xs:annotation>
                                    <xs:documentation>The default for all sql data. This is not
                                      required to be specified but it included here for completenes.
                                      Note all numeric sql datatypes will also be converted to
                                      varchar by default. If you dont want the default conversion
                                      then specify a format mask on the source sql
                                      code</xs:documentation>
                                  </xs:annotation>
                                </xs:enumeration>
                                <xs:enumeration value="xmltype">
                                  <xs:annotation>
                                    <xs:documentation>Inplies the api datatype will be converted
                                      between XMLTYPE and the datadomtype. The datadom data must be
                                      able to be cast as XML data for this to
                                      work</xs:documentation>
                                  </xs:annotation>
                                </xs:enumeration>
                                <xs:enumeration value="clob"/>
                                <xs:enumeration value="date"/>
                              </xs:restriction>
                            </xs:simpleType>
                          </xs:attribute>
                          <xs:attribute name="sql-column-name" use="required">
                            <xs:annotation>
                              <xs:documentation>The column name on the sql table. Any processing on
                                this table will convert between the datadom-type and the
                                sql-type</xs:documentation>
                            </xs:annotation>
                            <xs:simpleType>
                              <xs:restriction base="fm:entered-string">
                                <xs:maxLength value="31"/>
                              </xs:restriction>
                            </xs:simpleType>
                          </xs:attribute>
                        </xs:extension>
                      </xs:simpleContent>
                    </xs:complexType>
                  </xs:element>
                  <xs:element name="for-each" minOccurs="0" maxOccurs="unbounded">
                    <xs:annotation>
                      <xs:documentation>FOR-EACH actions execute in context of the target records.
                        The for-each actions can in turn specify further DML or DO-ACTION
                        calls.</xs:documentation>
                    </xs:annotation>
                    <xs:complexType>
                      <xs:annotation>
                        <xs:documentation>FOR-EACH actions execute in context of the target records.
                          The for-each actions can in turn specify further DO ACTION/DML
                          calls</xs:documentation>
                      </xs:annotation>
                      <xs:sequence>
                        <xs:element name="do" type="fm:do-block-type"/>
                      </xs:sequence>
                      <xs:attribute name="pre-ins" type="fm:yn-flag">
                        <xs:annotation>
                          <xs:documentation>block to be before an insert</xs:documentation>
                        </xs:annotation>
                      </xs:attribute>
                      <xs:attribute name="post-ins" type="fm:yn-flag">
                        <xs:annotation>
                          <xs:documentation>block executed after ( an insert</xs:documentation>
                        </xs:annotation>
                      </xs:attribute>
                      <xs:attribute name="pre-upd" type="fm:yn-flag">
                        <xs:annotation>
                          <xs:documentation>block executed before an update</xs:documentation>
                        </xs:annotation>
                      </xs:attribute>
                      <xs:attribute name="post-upd" type="fm:yn-flag">
                        <xs:annotation>
                          <xs:documentation>block executed after an update</xs:documentation>
                        </xs:annotation>
                      </xs:attribute>
                      <xs:attribute name="pre-del" type="fm:yn-flag">
                        <xs:annotation>
                          <xs:documentation>block executed before delete</xs:documentation>
                        </xs:annotation>
                      </xs:attribute>
                      <xs:attribute name="post-del" type="fm:yn-flag">
                        <xs:annotation>
                          <xs:documentation>block executed after a delete</xs:documentation>
                        </xs:annotation>
                      </xs:attribute>
                    </xs:complexType>
                  </xs:element>
                </xs:sequence>
                <xs:attribute name="name" type="fm:entered-string" use="required">
                  <xs:annotation>
                    <xs:documentation>Indentifies the database table to lock and/or
                      maintain</xs:documentation>
                  </xs:annotation>
                </xs:attribute>
                <xs:attribute name="cols" type="xs:positiveInteger" use="required">
                  <xs:annotation>
                    <xs:documentation>a check sum attribute which must match the number of columns
                      included in the DML interface. It is hoped the module specifier computes cols
                      from requirements, rather than counting up elements with {interface}=.
                      attributes in the module specification</xs:documentation>
                  </xs:annotation>
                </xs:attribute>
                <xs:attribute name="ins" type="fm:yn-flag" use="optional">
                  <xs:annotation>
                    <xs:documentation>Insert priviledge allowed</xs:documentation>
                  </xs:annotation>
                </xs:attribute>
                <xs:attribute name="upd" type="fm:yn-flag" use="optional">
                  <xs:annotation>
                    <xs:documentation>Update priviledge allowed</xs:documentation>
                  </xs:annotation>
                </xs:attribute>
                <xs:attribute name="del" type="fm:yn-flag" use="optional">
                  <xs:annotation>
                    <xs:documentation>Delete priviledge allowed</xs:documentation>
                  </xs:annotation>
                </xs:attribute>
                <xs:attribute name="lock-when" type="xs:string">
                  <xs:annotation>
                    <xs:documentation>In addition to the DML match tag and the rec-path match tag
                      this tag specifies extra XML search conditions to further restrict records for
                      processing</xs:documentation>
                  </xs:annotation>
                </xs:attribute>
                <xs:attribute name="del-when" type="xs:string" use="optional">
                  <xs:annotation>
                    <xs:documentation>In additions to the DML match tag and the rec-path match tag
                      this tag specifies extra XML search conditions to further restrict records for
                      processing</xs:documentation>
                  </xs:annotation>
                </xs:attribute>
                <xs:attribute name="namespace" type="fm:entered-string" use="optional">
                  <xs:annotation>
                    <xs:documentation>Corresponds to ns in the ns:cols attribute of a fox element
                      definition (to map dom columns to database columns) </xs:documentation>
                  </xs:annotation>
                </xs:attribute>
              </xs:complexType>
            </xs:element>
            <xs:group ref="fm:db-interface-query-grp"/>
            <xs:group ref="fm:db-interface-api-grp"/>
          </xs:sequence>
          <xs:attribute name="name" type="fm:entered-string" use="required">
            <xs:annotation>
              <xs:documentation source="This interface name must be uniqe for the module. "/>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="stub-overload"/>
          <xs:attribute name="build-only"/>
        </xs:complexType>
        <xs:key name="api-name-pkey">
          <xs:selector xpath="api"/>
          <xs:field xpath="@name"/>
        </xs:key>
        <xs:key name="query-name-pkey">
          <xs:selector xpath="fm:query"/>
          <xs:field xpath="@name"/>
        </xs:key>
        <xs:key name="table-name-pkey">
          <xs:selector xpath="fm:table"/>
          <xs:field xpath="@name"/>
        </xs:key>
      </xs:element>
    </xs:sequence>
  </xs:group>
  <xs:group name="db-interface-query-grp">
    <xs:sequence>
      <xs:element name="query" minOccurs="0" maxOccurs="unbounded">
        <xs:annotation>
          <xs:documentation>Defines query operations to populate the DOM from the database and lock
            database rows.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="target-path" minOccurs="0">
              <xs:annotation>
                <xs:documentation>Defines the DOM target for all select tags. Mandatory for
                  non-singleton selects.</xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:attribute name="match" type="fm:fox-xpath-type">
                  <xs:annotation>
                    <xs:documentation>Specifies the relative path of context nodes to process. When
                      the target name is '.' the query must select only one row. Any missing
                      intermediate target nodes are created automatically even if the query returns
                      no rows.</xs:documentation>
                  </xs:annotation>
                </xs:attribute>
              </xs:complexType>
            </xs:element>
            <xs:element name="primary" minOccurs="0">
              <xs:annotation>
                <xs:documentation>Required for QUERY AUGMENT and PURGE-SELECTED modes, when the target name is not �.�.</xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:element name="key" type="fm:entered-string" maxOccurs="unbounded">
                    <xs:annotation>
                      <xs:documentation>The PRIMARY or composite part of the primary key for the
                        records selected. This refers to a DOM element name</xs:documentation>
                    </xs:annotation>
                  </xs:element>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
            <xs:element name="pagination-definition" type="fm:entered-string" minOccurs="0"/>
            <xs:element minOccurs="0" name="pagination-config">
              <xs:annotation>
                <xs:documentation>Configuration options for Top-N paging. The presence of this element declares the query as a Top-N paginated query when it is invoked with a pagination-invoke-name. You must specify at least one of the row-from-bind-name and offset-bind-name attributes, and at least one of the row-to-bind-name and page-size-bind-name attributes.</xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:attribute name="row-from-bind-name" type="fm:entered-string">
                  <xs:annotation>
                    <xs:documentation>Name of the "row from" bind variable. This bind is the first row number (inclusive) which should be selected by the query, i.e. as the first argument of a BETWEEN clause.</xs:documentation>
                  </xs:annotation>
                </xs:attribute>
                <xs:attribute name="row-to-bind-name" type="fm:entered-string">
                  <xs:annotation>
                    <xs:documentation>Name of the "row to" bind variable. This bind is the last row number (inclusive) which should be selected by the query, i.e. as the second argument of a BETWEEN clause.</xs:documentation>
                  </xs:annotation>
                </xs:attribute>
                <xs:attribute name="offset-bind-name" type="fm:entered-string">
                  <xs:annotation>
                    <xs:documentation>Name of the "offset" bind variable. This bind is the 0-based offset to the first row which should be selected by the query, i.e. as the OFFSET argument of an Oracle 12c Top-N query. Equivalent to row-from-bind-name - 1.</xs:documentation>
                  </xs:annotation>
                </xs:attribute>
                <xs:attribute name="page-size-bind-name" type="fm:entered-string">
                  <xs:annotation>
                    <xs:documentation>Name of the "page size" bind variable. This bind is number of rows to be selected for a page, i.e. as the NEXT ROWS argument of an Oracle 12c Top-N query.</xs:documentation>
                  </xs:annotation>
                </xs:attribute>
                <xs:attribute name="scn-bind-name" type="fm:entered-string">
                  <xs:annotation>
                    <xs:documentation>Name of the SCN bind variable, for use in the "AS OF SCN" clause of a flashback query.</xs:documentation>
                  </xs:annotation>
                </xs:attribute>
                <xs:attribute name="row-count-column-name" type="fm:entered-string">
                  <xs:annotation>
                    <xs:documentation>Name of the column returned by the query which contains its overall row count. Case sensitive.</xs:documentation>
                  </xs:annotation>
                </xs:attribute>
              </xs:complexType>
            </xs:element>
            <xs:element name="select" type="fm:entered-string">
              <xs:annotation>
                <xs:documentation>Any oracle SQL statment. Input Bind variables are supported. DOM
                  target data elements are specified as column aliases in the select statement
                  itself or by using the into tag</xs:documentation>
              </xs:annotation>
            </xs:element>
            <xs:element name="using" minOccurs="0" maxOccurs="unbounded">
              <xs:annotation>
                <xs:documentation>Specifies input parameters to the SQL query </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:attribute name="name">
                      <xs:annotation>
                        <xs:documentation>Specifies the name of the input bind variable. This can be
                          of the format :1, :2 etc or a name such as :emp_id</xs:documentation>
                      </xs:annotation>
                      <xs:simpleType>
                        <xs:restriction base="fm:entered-string">
                          <xs:maxLength value="31"/>
                        </xs:restriction>
                      </xs:simpleType>
                    </xs:attribute>
                    <xs:attribute name="datadom-location" type="fm:fox-xpath-type">
                      <xs:annotation>
                        <xs:documentation>The xpath identifying the source node(s). By default the
                          data is treated as the value of the node. This can be overridden by the
                          datadom-type such as dom which picks up any child nodes as well
                        </xs:documentation>
                      </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="datadom-type">
                      <xs:annotation>
                        <xs:documentation>The FOX dom type that this attribute maps to. If not
                          entered fox will attempt to resolve the type at runtime (usually string)
                        </xs:documentation>
                      </xs:annotation>
                      <xs:simpleType>
                        <xs:restriction base="fm:entered-string">
                          <xs:enumeration value="xs:string">
                            <xs:annotation>
                              <xs:documentation>this is the default and should normally be
                                specified. It is put here for descriptive purposes
                                only</xs:documentation>
                            </xs:annotation>
                          </xs:enumeration>
                          <xs:enumeration value="dom">
                            <xs:annotation>
                              <xs:documentation>This will operate on the node and all sub nodes. The
                                equivalent sql-data must be able to be cast as an xml
                                type.</xs:documentation>
                            </xs:annotation>
                          </xs:enumeration>
                          <xs:enumeration value="xs:date">
                            <xs:annotation>
                              <xs:documentation>CCYYMMDD</xs:documentation>
                            </xs:annotation>
                          </xs:enumeration>
                          <xs:enumeration value="xs:datetime">
                            <xs:annotation>
                              <xs:documentation>CCYYMMDDThh:mm:ss</xs:documentation>
                            </xs:annotation>
                          </xs:enumeration>
                          <xs:enumeration value="xs:time">
                            <xs:annotation>
                              <xs:documentation>hh:mm:ss</xs:documentation>
                            </xs:annotation>
                          </xs:enumeration>
                        </xs:restriction>
                      </xs:simpleType>
                    </xs:attribute>
                    <xs:attribute name="sql-type">
                      <xs:annotation>
                        <xs:documentation>The sql datatype in the database. If not entered then FOX
                          will try to determine the datatype at runtime</xs:documentation>
                      </xs:annotation>
                      <xs:simpleType>
                        <xs:restriction base="fm:entered-string">
                          <xs:enumeration value="varchar">
                            <xs:annotation>
                              <xs:documentation>The default for all sql data. This is not required
                                to be specified but it included here for completenes. Note all
                                numeric sql datatypes will also be converted to varchar by default.
                                If you dont want the default conversion then specify a format mask
                                on the source sql code</xs:documentation>
                            </xs:annotation>
                          </xs:enumeration>
                          <xs:enumeration value="xmltype">
                            <xs:annotation>
                              <xs:documentation>Inplies the api datatype will be converted between
                                XMLTYPE and the datadomtype. The datadom data must be able to be
                                cast as XML data for this to work</xs:documentation>
                            </xs:annotation>
                          </xs:enumeration>
                          <xs:enumeration value="clob"/>
                          <xs:enumeration value="date"/>
                        </xs:restriction>
                      </xs:simpleType>
                    </xs:attribute>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name="template-variable" minOccurs="0" maxOccurs="unbounded">
              <xs:annotation>
                <xs:documentation>Provides a value for a template variable in templated queries. If a many item sequence is resolved by the XPath, only the first item is considered.</xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:attribute name="name" use="required">
                      <xs:annotation>
                        <xs:documentation>Specifies the name of the template variable the value corresponds to.</xs:documentation>
                      </xs:annotation>
                      <xs:simpleType>
                        <xs:restriction base="fm:entered-string">
                          <xs:maxLength value="31"/>
                        </xs:restriction>
                      </xs:simpleType>
                    </xs:attribute>
                    <xs:attribute name="datadom-type" use="optional">
                      <xs:annotation>
                        <xs:documentation>Specifies how DOM nodes from the XPath are bound into the template. For 'string' the string value is used. For 'dom', node existence is bound as a boolean (i.e. 'true' if the node exists). Other item types are unaffected.</xs:documentation>
                      </xs:annotation>
                      <xs:simpleType>
                        <xs:restriction base="fm:entered-string">
                          <xs:enumeration value="string"/>
                          <xs:enumeration value="dom"/>
                        </xs:restriction>
                      </xs:simpleType>
                    </xs:attribute>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name="into" minOccurs="0" maxOccurs="unbounded">
              <xs:annotation>
                <xs:documentation>Specifies output parameters from SQL to a dom
                  target</xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:attribute name="name" use="required">
                      <xs:annotation>
                        <xs:documentation>Specifies the name of the column alias in the query. Use
                          this name when you want to a) Use an xpath longer than 31 characters (in
                          this case put it in the datadom-location) b) Want to override the default
                          sql /dom data conversion rules</xs:documentation>
                      </xs:annotation>
                      <xs:simpleType>
                        <xs:restriction base="fm:entered-string">
                          <xs:maxLength value="31"/>
                        </xs:restriction>
                      </xs:simpleType>
                    </xs:attribute>
                    <xs:attribute name="datadom-location" type="fm:fox-xpath-type">
                      <xs:annotation>
                        <xs:documentation>The xpath identifying the source node(s). By default the
                          data is treated as the value of the node. This can be overridden by the
                          datadom-type such as dom which picks up any child nodes as well
                        </xs:documentation>
                      </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="datadom-type">
                      <xs:annotation>
                        <xs:documentation>The FOX dom type that this attribute maps to. If not
                          entered fox will attempt to resolve the type at runtime (usually string)
                        </xs:documentation>
                      </xs:annotation>
                      <xs:simpleType>
                        <xs:restriction base="fm:entered-string">
                          <xs:enumeration value="xs:string">
                            <xs:annotation>
                              <xs:documentation>this is the default and should normally be
                                specified. It is put here for descriptive purposes
                                only</xs:documentation>
                            </xs:annotation>
                          </xs:enumeration>
                          <xs:enumeration value="xs:date">
                            <xs:annotation>
                              <xs:documentation>CCYYMMDD</xs:documentation>
                            </xs:annotation>
                          </xs:enumeration>
                          <xs:enumeration value="xs:dateTime">
                            <xs:annotation>
                              <xs:documentation>CCYYMMDDThh:mm:ss</xs:documentation>
                            </xs:annotation>
                          </xs:enumeration>
                          <xs:enumeration value="xs:time">
                            <xs:annotation>
                              <xs:documentation>hh:mm:ss</xs:documentation>
                            </xs:annotation>
                          </xs:enumeration>
                          <xs:enumeration value="dom">
                            <xs:annotation>
                              <xs:documentation>This will operate on the node and all sub nodes. The
                                equivalent sql-data must be able to be cast as an xml
                                type.</xs:documentation>
                            </xs:annotation>
                          </xs:enumeration>
                        </xs:restriction>
                      </xs:simpleType>
                    </xs:attribute>
                    <xs:attribute name="sql-type">
                      <xs:annotation>
                        <xs:documentation>The sql datatype in the database. If not entered then FOX
                          will try to determine the datatype at runtime</xs:documentation>
                      </xs:annotation>
                      <xs:simpleType>
                        <xs:restriction base="fm:entered-string">
                          <xs:enumeration value="varchar">
                            <xs:annotation>
                              <xs:documentation>The default for all sql data. This is not required
                                to be specified but it included here for completenes. Note all
                                numeric sql datatypes will also be converted to varchar by default.
                                If you dont want the default conversion then specify a format mask
                                on the source sql code</xs:documentation>
                            </xs:annotation>
                          </xs:enumeration>
                          <xs:enumeration value="xmltype">
                            <xs:annotation>
                              <xs:documentation>Inplies the api datatype will be converted between
                                XMLTYPE and the datadomtype. The datadom data must be able to be
                                cast as XML data for this to work</xs:documentation>
                            </xs:annotation>
                          </xs:enumeration>
                          <xs:enumeration value="clob"/>
                          <xs:enumeration value="date"/>
                        </xs:restriction>
                      </xs:simpleType>
                    </xs:attribute>
                    <xs:attribute name="dom-merge-mode">
                      <xs:annotation>
                        <xs:documentation>Defines the merge behaviour used when a DOM column is
                          selected into an existing DOM node.</xs:documentation>
                      </xs:annotation>
                      <xs:simpleType>
                        <xs:restriction base="fm:entered-string">
                          <xs:enumeration value="add-to">
                            <xs:annotation>
                              <xs:documentation>Default merge mode - the existing XML is preserved
                                in the target node and new nodes are added underneath it.</xs:documentation>
                            </xs:annotation>
                          </xs:enumeration>
                          <xs:enumeration value="purge">
                            <xs:annotation>
                              <xs:documentation>Causes the target DOM node to be purged of all child
                                nodes before the selected XML is written into it.</xs:documentation>
                            </xs:annotation>
                          </xs:enumeration>
                        </xs:restriction>
                      </xs:simpleType>
                    </xs:attribute>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name="row-lock" minOccurs="0">
              <xs:complexType>
                <xs:sequence>
                  <xs:element name="select" type="fm:entered-string">
                    <xs:annotation>
                      <xs:documentation>Any oracle SQL statment. Input Bind variables are supported.
                        DOM target data elements are specified as column aliases in the select
                        statement itself. RULE1: select item set here must be a strict superset of
                        queries select item set. RULE2: query must return exectly one row (or zero
                        if deleted row commmited by another session). RULE3: the onus is on the
                        developer/architect to get index access correct.</xs:documentation>
                    </xs:annotation>
                  </xs:element>
                  <xs:element name="current-of-item" type="fm:entered-string" maxOccurs="unbounded"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
            <xs:element name="for-each-fetch" minOccurs="0" maxOccurs="unbounded">
              <xs:annotation>
                <xs:documentation>FOR-EACH-FETCH actions execute in context of the target records.
                  The for-each actions can in turn specify further DML or DO-ACTION
                  calls.</xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:element name="do" type="fm:do-block-type"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
          </xs:sequence>
          <xs:attribute name="name" type="fm:entered-string" use="required">
            <xs:annotation>
              <xs:documentation>This query name must be uniqe for the interface. The name is
                reference in the run-queryi interface tag</xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="mode" default="AUGMENT">
            <xs:annotation>
              <xs:documentation>Operation to apply todata at the target record. Target modes
                currently are: Target Mode Key Required Performance (Default) AUGMENT YES unless .
                SLOW PURGE-SELECTED YES unless . SLOW PURGE-ALL NO EFFICIENT ADD-TO NO QUICKEST Cann
                be overidden at dml mode tag level</xs:documentation>
            </xs:annotation>
            <xs:simpleType>
              <xs:restriction base="fm:entered-string">
                <xs:enumeration value="PURGE-SELECTED"/>
                <xs:enumeration value="PURGE-ALL"/>
                <xs:enumeration value="AUGMENT"/>
                <xs:enumeration value="ADD-TO"/>
              </xs:restriction>
            </xs:simpleType>
          </xs:attribute>
          <xs:attribute default="none" name="template-type">
            <xs:annotation>
              <xs:documentation>If set to 'mustache', Mustache template syntax in the fm:query is expanded based on the values of fm:using and fm:template-variable binds before the query is executed. Default is 'none'.</xs:documentation>
            </xs:annotation>
            <xs:simpleType>
              <xs:restriction base="xs:string">
                <xs:enumeration value="none"/>
                <xs:enumeration value="mustache"/>
              </xs:restriction>
            </xs:simpleType>
          </xs:attribute>
          <xs:attribute name="stub-overload"/>
          <xs:attribute name="build-only"/>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:group>
  <xs:group name="db-interface-api-grp">
    <xs:sequence>
      <xs:element name="api" minOccurs="0" maxOccurs="unbounded">
        <xs:annotation>
          <xs:documentation>Allows a call interface to any language such as as SQL code block. APIs
            can receive and return DOM elements but locking, integrity and security is the
            responsibility of the api call and not FOX</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="statement">
              <xs:annotation>
                <xs:documentation>An anonymous pl/sql block with bind variables</xs:documentation>
              </xs:annotation>
            </xs:element>
            <xs:element name="using" minOccurs="0" maxOccurs="unbounded">
              <xs:annotation>
                <xs:documentation>Specifies input/output parameters for SQL </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:attribute name="direction" default="in">
                      <xs:annotation>
                        <xs:documentation>input/output parameter direction</xs:documentation>
                      </xs:annotation>
                      <xs:simpleType>
                        <xs:restriction base="fm:entered-string">
                          <xs:enumeration value="in">
                            <xs:annotation>
                              <xs:documentation>input from the datadom to the sql api
                                parameter</xs:documentation>
                            </xs:annotation>
                          </xs:enumeration>
                          <xs:enumeration value="out">
                            <xs:annotation>
                              <xs:documentation>output from the sql api parameter to the
                                datadom</xs:documentation>
                            </xs:annotation>
                          </xs:enumeration>
                          <xs:enumeration value="in out"/>
                        </xs:restriction>
                      </xs:simpleType>
                    </xs:attribute>
                    <xs:attribute name="datadom-location" type="fm:fox-xpath-type">
                      <xs:annotation>
                        <xs:documentation>The xpath identifying the source node(s). By default the
                          data is treated as the value of the node. This can be overridden by the
                          datadom-type such as dom which picks up any child nodes as well
                        </xs:documentation>
                      </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="datadom-type">
                      <xs:annotation>
                        <xs:documentation>The FOX dom type that this attribute maps to. If not
                          entered fox will attempt to resolve the type at runtime (usually string)
                        </xs:documentation>
                      </xs:annotation>
                      <xs:simpleType>
                        <xs:restriction base="fm:entered-string">
                          <xs:enumeration value="string">
                            <xs:annotation>
                              <xs:documentation>this is the default and should normally be
                                specified. It is put here for descriptive purposes
                                only</xs:documentation>
                            </xs:annotation>
                          </xs:enumeration>
                          <xs:enumeration value="dom">
                            <xs:annotation>
                              <xs:documentation>This will operate on the node and all sub nodes. The
                                equivalent sql-data must be able to be cast as an xml
                                type.</xs:documentation>
                            </xs:annotation>
                          </xs:enumeration>
                          <xs:enumeration value="date">
                            <xs:annotation>
                              <xs:documentation>CCYYMMDD</xs:documentation>
                            </xs:annotation>
                          </xs:enumeration>
                          <xs:enumeration value="datetime">
                            <xs:annotation>
                              <xs:documentation>CCYYMMDDThh:mm:ss</xs:documentation>
                            </xs:annotation>
                          </xs:enumeration>
                          <xs:enumeration value="time">
                            <xs:annotation>
                              <xs:documentation>hh:mm:ss</xs:documentation>
                            </xs:annotation>
                          </xs:enumeration>
                        </xs:restriction>
                      </xs:simpleType>
                    </xs:attribute>
                    <xs:attribute name="sql-type">
                      <xs:annotation>
                        <xs:documentation>The sql datatype in the database. If not entered then FOX
                          will try to determine the datatype at runtime</xs:documentation>
                      </xs:annotation>
                      <xs:simpleType>
                        <xs:restriction base="fm:entered-string">
                          <xs:enumeration value="varchar">
                            <xs:annotation>
                              <xs:documentation>The default for all sql data.
                                This is not required to be specified but it included here for completenes.
                                Note all numeric sql datatypes will also be converted to varchar by default.
                                If you dont want the default conversion then specify a format mask on the source sql code</xs:documentation>
                            </xs:annotation>
                          </xs:enumeration>
                          <xs:enumeration value="xmltype">
                            <xs:annotation>
                              <xs:documentation>Inplies the api datatype will be converted between XMLTYPE and the datadomtype. The datadom data must be able to be cast as XML data for this to work</xs:documentation>
                            </xs:annotation>
                          </xs:enumeration>
                          <xs:enumeration value="clob"/>
                          <xs:enumeration value="date"/>
                        </xs:restriction>
                      </xs:simpleType>
                    </xs:attribute>
                    <xs:attribute name="name" type="fm:entered-string"/>
                    <xs:attribute name="dom-merge-mode">
                      <xs:annotation>
                        <xs:documentation>Defines the merge behaviour used when a DOM column is
                          selected into an existing DOM node.</xs:documentation>
                      </xs:annotation>
                      <xs:simpleType>
                        <xs:restriction base="fm:entered-string">
                          <xs:enumeration value="add-to">
                            <xs:annotation>
                              <xs:documentation>Default merge mode - the existing XML is preserved
                                in the target node and new nodes are added underneath it.</xs:documentation>
                            </xs:annotation>
                          </xs:enumeration>
                          <xs:enumeration value="purge">
                            <xs:annotation>
                              <xs:documentation>Causes the target DOM node to be purged of all child
                                nodes before the selected XML is written into it.</xs:documentation>
                            </xs:annotation>
                          </xs:enumeration>
                        </xs:restriction>
                      </xs:simpleType>
                    </xs:attribute>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
          </xs:sequence>
          <xs:attribute name="name" type="fm:entered-string" use="required">
            <xs:annotation>
              <xs:documentation>This api name must be uniqe for the interface. The name is reference
                in the run-api interface tag</xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="mode" default="AUGMENT">
            <xs:annotation>
              <xs:documentation>Operation to apply todata at the target record. Target modes
                currently are: Target Mode Key Required Performance (Default) AUGMENT YES unless .
                SLOW PURGE-SELECTED YES unless . SLOW PURGE-ALL NO EFFICIENT ADD-TO NO QUICKEST Cann
                be overidden at dml mode tag level</xs:documentation>
            </xs:annotation>
            <xs:simpleType>
              <xs:restriction base="fm:entered-string">
                <xs:enumeration value="PURGE"/>
                <xs:enumeration value="PURGE-ALL"/>
                <xs:enumeration value="AUGMENT"/>
                <xs:enumeration value="ADD-TO"/>
              </xs:restriction>
            </xs:simpleType>
          </xs:attribute>
          <xs:attribute name="language" default="PL/SQL">
            <xs:annotation>
              <xs:documentation>Specifies the language of the api call. Initially only PL/SQL is
                supported</xs:documentation>
            </xs:annotation>
            <xs:simpleType>
              <xs:restriction base="fm:entered-string">
                <xs:enumeration value="PL/SQL"/>
                <xs:enumeration value="SOAP"/>
                <xs:enumeration value="JAVA"/>
              </xs:restriction>
            </xs:simpleType>
          </xs:attribute>
          <xs:attribute name="stub-overload"/>
          <xs:attribute name="build-only"/>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:group>
  <xs:group name="do-cmd-grp">
    <xs:annotation>
      <xs:documentation>Complex do command
        with verious control structures</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="do" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Complex do command
            with verious control structures</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="fm:do-block-type">
              <xs:attribute name="while-xpath" type="xs:string" use="optional"/>
              <xs:attribute name="until-xpath" type="xs:string" use="optional"/>
              <xs:attribute name="for-each-xpath" type="xs:string" use="optional"/>
              <xs:attribute name="num-range-from" type="xs:double" use="optional"/>
              <xs:attribute name="num-range-to" type="xs:double" use="optional"/>
              <xs:attribute name="num-range-step" type="xs:double" use="optional"/>
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:group>
  <xs:group name="fox-html-tags-grp">
    <xs:choice>
      <xs:element name="include" minOccurs="0">
        <xs:complexType mixed="true">
          <xs:attribute name="name" type="fm:entered-string"/>
          <xs:attribute name="attach" type="fm:fox-xpath-type"/>
          <xs:attribute name="client-visibility-rule" type="fm:entered-string"/>
        </xs:complexType>
      </xs:element>
      <xs:element name="set-out" type="fm:set-out-type"/>
      <xs:element name="widget-out" type="fm:widget-out-type"/>
      <xs:element name="action-out" minOccurs="0">
        <xs:complexType mixed="true">
          <xs:attribute name="action" type="fm:entered-string" use="required"/>
          <xs:attributeGroup ref="fox:zzz-action-out-attr-grp"/>
          <xs:attribute name="action-context" type="fm:fox-xpath-type" use="optional">
            <xs:annotation>
              <xs:documentation>Sets :{action} to the node specified by this XPath</xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:anyAttribute namespace="##other" processContents="skip"/>
        </xs:complexType>
      </xs:element>
      <xs:element name="menu-out" type="fm:menu-out-type"/>
      <xs:element name="expr-out" minOccurs="0">
        <xs:complexType mixed="true">
          <xs:attribute name="match" type="fm:fox-xpath-type" use="optional" default="."/>
          <xs:attribute name="type" use="optional" default="xs:string">
            <xs:simpleType>
              <xs:restriction base="xs:string">
                <xs:enumeration value="xs:string"/>
                <xs:enumeration value="xs:date"/>
                <xs:enumeration value="xs:dateTime"/>
                <xs:enumeration value="xs:decimal"/>
                <xs:enumeration value="xs:anyType"/>
              </xs:restriction>
            </xs:simpleType>
          </xs:attribute>
          <xs:attribute name="formatMask" type="xs:string" use="optional"/>
          <xs:attribute name="mapsetName" type="xs:string" use="optional"/>
          <xs:attribute name="mapsetItem" type="xs:string" use="optional"/>
          <xs:attribute name="mapsetAttach" type="xs:string" use="optional"/>
        </xs:complexType>
      </xs:element>
      <xs:element name="for-each" minOccurs="0">
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="html-or-fox-html-tags-type">
              <xs:attribute name="xpath" type="fm:fox-xpath-type" use="optional"/>
              <xs:attribute name="num-range-from" type="xs:double" use="optional"/>
              <xs:attribute name="num-range-to" type="xs:double" use="optional"/>
              <xs:attribute name="num-range-step" type="xs:double" use="optional"/>
              <xs:attribute name="itemContextName" type="fm:entered-string" use="optional"/>
              <xs:attribute name="statusContextName" type="fm:entered-string" use="optional"/>
              <xs:attribute name="pagination-definition" type="fm:entered-string" use="optional"/>
              <xs:attribute name="pagination-invoke-name" type="fm:entered-string" use="optional"/>
              <xs:attribute name="page-size" type="fm:entered-string" use="optional"/>
              <xs:attribute name="page-controls-position" use="optional">
                <xs:simpleType>
                  <xs:restriction base="fm:entered-string">
                    <xs:enumeration value="above"/>
                    <xs:enumeration value="below"/>
                    <xs:enumeration value="both"/>
                    <xs:enumeration value="none"/>
                  </xs:restriction>
                </xs:simpleType>
              </xs:attribute>
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="if" minOccurs="0">
        <xs:complexType>
          <xs:sequence minOccurs="0">
            <xs:element name="then">
              <xs:complexType>
                <xs:complexContent>
                  <xs:extension base="html-or-fox-html-tags-type"/>
                </xs:complexContent>
              </xs:complexType>
            </xs:element>
            <xs:sequence minOccurs="0" maxOccurs="unbounded">
              <xs:element name="else-if">
                <xs:complexType>
                  <xs:complexContent>
                    <xs:extension base="html-or-fox-html-tags-type">
                      <xs:attribute name="test" type="fm:fox-xpath-type" use="required"/>
                    </xs:extension>
                  </xs:complexContent>
                </xs:complexType>
              </xs:element>
            </xs:sequence>
            <xs:element name="else" type="html-or-fox-html-tags-type" minOccurs="0"/>
          </xs:sequence>
          <xs:attribute name="test" type="fm:fox-xpath-type" use="required"/>
        </xs:complexType>
      </xs:element>
      <xs:element name="case">
        <xs:annotation>
          <xs:documentation>A searched case statement similar to the Oracle PL/SQL implementation.

            If present, the attribute "expr" is evaluated and must yield a single value, otherwise the "value" attribute
            must be set. In either case, the single string value yielded will be checked against each fm:when element in
            turn until a match is found, or fm:default is reached.

            fm:when elements also have the attributes "expr" and "value", only one may be set. If the "value" attribute
            or the value resulting from the "expr" attribute match the value of the fm:case, then the action contents of
            fm:case are evaluated.

            If the "continue-matching" attribute is set to "true", then after the fm:when contents are evaluated, the
            command will continue to compare the original value against the subsequent fm:when element(s) until a further
            match is found, or fm:default is reached. This allows multiple fm:when elements to be evaluated if desired.

            If the fm:default element is reached, then its contents are evaluated.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="when" maxOccurs="unbounded">
              <xs:complexType>
                <xs:complexContent>
                  <xs:extension base="html-or-fox-html-tags-type">
                    <xs:attributeGroup ref="fm:case-attr-grp"/>
                    <xs:attribute name="continue-matching" type="xs:boolean" use="optional"/>
                  </xs:extension>
                </xs:complexContent>
              </xs:complexType>
            </xs:element>
            <xs:element name="default" type="html-or-fox-html-tags-type" minOccurs="0"/>
          </xs:sequence>
          <xs:attributeGroup ref="fm:case-attr-grp"/>
        </xs:complexType>
      </xs:element>
      <xs:element name="external-url" minOccurs="0">
        <xs:complexType>
          <xs:attribute name="href" type="xs:string" use="required"/>
          <xs:attribute name="text" type="xs:string" use="required"/>
          <xs:attribute name="type" use="optional" default="fullwin">
            <xs:simpleType>
              <xs:restriction base="xs:string">
                <xs:enumeration value="appwin"/>
                <xs:enumeration value="searchwin"/>
                <xs:enumeration value="filewin"/>
                <xs:enumeration value="fullwin"/>
                <xs:enumeration value="refwin"/>
                <xs:enumeration value="helpwin"/>
                <xs:enumeration value="flushwin"/>
              </xs:restriction>
            </xs:simpleType>
          </xs:attribute>
          <xs:attribute name="contextParams" type="xs:boolean" default="false"/>
        </xs:complexType>
      </xs:element>
      <xs:element name="error-out">
        <xs:complexType>
          <xs:attribute name="no-display" type="xs:boolean" use="optional"/>
        </xs:complexType>
      </xs:element>
      <xs:element name="hint-out">
        <xs:complexType>
          <xs:attribute ref="fox:hint-url"/>
          <xs:attribute name="text" type="fm:entered-string" use="required"/>
          <xs:attribute name="prompt" type="fm:entered-string" use="optional"/>
          <xs:attribute name="imageUrl" type="fm:entered-string" use="optional"/>
        </xs:complexType>
      </xs:element>
      <xs:element name="mail-to" minOccurs="0">
        <xs:complexType>
          <xs:attribute name="email" type="fm:entered-string" use="required">
            <xs:annotation>
              <xs:documentation>The primary email address(es) to send email to. Can be an XPath if wrapped with the string() function.</xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="cc" type="fm:entered-string" use="optional">
            <xs:annotation>
              <xs:documentation>The cc email address(es) to send email to. Can be an XPath if wrapped with the string() function.</xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="prompt" type="fm:entered-string" use="optional">
            <xs:annotation>
              <xs:documentation>The link text (that will be displayed to the user). Can be an XPath if wrapped with the string() function.</xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="subject" type="fm:entered-string" use="optional">
            <xs:annotation>
              <xs:documentation>The suject of the email. Can be an XPath if wrapped with the string() function.</xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="imageUrl" type="fm:entered-string" use="optional">
            <xs:annotation>
              <xs:documentation>Specified as image to use as the link body instead of text. Can be an XPath if wrapped with the string() function.</xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="hint" type="fm:entered-string" use="optional">
            <xs:annotation>
              <xs:documentation>Specified the hint text to display if the link / image is hovered over. Can be an XPath if wrapped with the string() function.</xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>
      <xs:element name="page-controls-out">
        <xs:complexType>
          <xs:attribute name="invoke-name" type="xs:string" use="required"/>
          <xs:attribute name="match" type="fm:fox-xpath-type" use="optional"/>
        </xs:complexType>
      </xs:element>
      <xs:element name="evaluate-attributes" minOccurs="0">
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="html-or-fox-html-tags-type">
              <xs:attribute name="attr-list-csv" type="fm:entered-string" use="required"/>
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="heading">
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="html-or-fox-html-tags-type">
              <xs:attribute name="level" type="xs:integer" use="required"/>
              <xs:attribute name="class" type="fm:fox-xpath-type" use="optional"/>
              <xs:attribute name="style" type="fm:fox-xpath-type" use="optional"/>
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="grid">
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="html-or-fox-html-tags-type">
              <xs:attribute name="formColumns" type="fm:fox-xpath-type" use="optional"/>
              <xs:attribute name="class" type="fm:fox-xpath-type" use="optional"/>
              <xs:attribute name="style" type="fm:fox-xpath-type" use="optional"/>
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="row">
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="html-or-fox-html-tags-type">
              <xs:attribute name="class" type="fm:fox-xpath-type" use="optional"/>
              <xs:attribute name="style" type="fm:fox-xpath-type" use="optional"/>
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="cell">
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="html-or-fox-html-tags-type">
              <xs:attribute name="columnSpan" type="fm:fox-xpath-type" use="optional"/>
              <xs:attribute name="class" type="fm:fox-xpath-type" use="optional"/>
              <xs:attribute name="style" type="fm:fox-xpath-type" use="optional"/>
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="info-box">
        <xs:complexType>
          <xs:sequence>
            <xs:element name="title" minOccurs="0" maxOccurs="1">
              <xs:complexType>
                <xs:complexContent>
                  <xs:extension base="html-or-fox-html-tags-type">
                    <xs:attribute name="level" type="xs:integer" use="optional"/>
                  </xs:extension>
                </xs:complexContent>
              </xs:complexType>
            </xs:element>
            <xs:element name="content" minOccurs="1" maxOccurs="1" type="html-or-fox-html-tags-type"/>
          </xs:sequence>
          <xs:attribute name="type" use="optional" default="info">
            <xs:annotation>
              <xs:documentation>
                Stringifyable, must resolve to one of the following: 'info', 'success', 'warning', 'danger'.
              </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
              <xs:union memberTypes="fm:fox-xpath-type fox:notification-display-type"/>
            </xs:simpleType>
          </xs:attribute>
          <xs:attribute name="class" type="fm:fox-xpath-type" use="optional"/>
          <xs:attribute name="style" type="fm:fox-xpath-type" use="optional"/>
        </xs:complexType>
      </xs:element>
      <xs:element name="tab-group">
        <xs:complexType>
          <xs:sequence minOccurs="1" maxOccurs="unbounded">
            <xs:choice>
              <xs:element name="tab" type="fm:tab-type"/>
              <xs:element name="tab-for-each-dom" type="fm:tab-for-each-dom-type"/>
              <xs:element name="tab-for-each-number" type="fm:tab-for-each-number-type"/>
            </xs:choice>
          </xs:sequence>
          <xs:attribute name="name" use="required" type="fm:entered-string"/>
          <xs:attribute name="attach" use="optional" default="." type="fm:entered-string"/>
          <xs:attribute name="tabStyle" use="optional">
            <xs:simpleType>
              <xs:restriction base="xs:string">
                <xs:enumeration value="standard"/>
                <xs:enumeration value="contained"/>
              </xs:restriction>
            </xs:simpleType>
          </xs:attribute>
          <xs:attribute name="size" use="optional" default="regular">
            <xs:simpleType>
              <xs:restriction base="xs:string">
                <xs:enumeration value="small"/>
                <xs:enumeration value="regular"/>
                <xs:enumeration value="big"/>
              </xs:restriction>
            </xs:simpleType>
          </xs:attribute>
          <xs:attribute name="class" use="optional" type="fm:entered-string"/>
          <xs:attribute name="multilineThreshold" use="optional" type="fm:entered-string"/>
          <xs:attribute name="preTabChangeAction" use="optional" type="fm:entered-string"/>
          <xs:attribute name="postTabChangeAction" use="optional" type="fm:entered-string"/>
          <xs:attribute name="clientSide" use="optional" type="fm:entered-string"/>
          <xs:attribute name="tabContainerStyle" use="optional" default="standard">
            <xs:simpleType>
              <xs:restriction base="xs:string">
                <xs:enumeration value="standard"/>
                <xs:enumeration value="contained"/>
              </xs:restriction>
            </xs:simpleType>
          </xs:attribute>
        </xs:complexType>
      </xs:element>
      <xs:element name="tab-prompt-link">
        <xs:complexType>
          <xs:attribute name="text" type="fm:entered-string" use="required"/>
        </xs:complexType>
      </xs:element>
      <xs:element name="label">
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="html-or-fox-html-tags-type">
              <xs:attribute name="for-target" type="fm:fox-xpath-type" use="optional">
                <xs:annotation>
                  <xs:documentation>XPath pointing to an element which, if set-out, this label should send focus to when clicked</xs:documentation>
                </xs:annotation>
              </xs:attribute>
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="header" type="fm:header-footer-type">
        <xs:annotation>
          <xs:documentation>Content that should be included in the header of every page output by the nearest containing buffer that specifies a page definition.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="footer" type="fm:header-footer-type">
        <xs:annotation>
          <xs:documentation>Content that should be included in the footer of every page output by the nearest containing buffer that specifies a page definition.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="current-page-number" type="fm:page-number-type">
        <xs:annotation>
          <xs:documentation>Outputs the current page number of a document. Only valid within a header or footer.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="last-page-number" type="fm:page-number-type">
        <xs:annotation>
          <xs:documentation>Outputs the current page number of a document. Only valid within a header or footer.</xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:choice>
  </xs:group>
  <xs:group name="set-buffer-grp">
    <xs:sequence>
      <xs:element name="set-buffer">
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="html-or-fox-html-tags-type">
              <xs:attribute name="name" type="fm:entered-string" use="required"/>
              <xs:attribute name="stub-overload"/>
              <xs:attribute name="build-only"/>
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:group>
  <xs:complexType name="set-out-type" mixed="true">
    <xs:attribute name="match" type="fm:fox-xpath-type" use="optional"/>
    <xs:attribute name="pagination-invoke-name" type="fm:entered-string" use="optional"/>
    <xs:attribute name="dom-pagination-invoke-name" type="fm:entered-string" use="optional"/>
    <xs:attribute name="page-size" type="fm:entered-string" use="optional"/>
    <xs:attribute name="pagination-definition" type="fm:entered-string" use="optional"/>
    <xs:attribute name="page-controls-position" use="optional">
      <xs:simpleType>
        <xs:restriction base="fm:entered-string">
          <xs:enumeration value="above"/>
          <xs:enumeration value="below"/>
          <xs:enumeration value="both"/>
          <xs:enumeration value="none"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attributeGroup ref="fox:zzz-set-out-attr-grp"/>
    <xs:anyAttribute namespace="##other" processContents="skip"/>
  </xs:complexType>
  <xs:complexType name="widget-out-type" mixed="true">
    <xs:attribute name="match" type="fm:fox-xpath-dom"/>
    <xs:attribute name="showPrompt" type="fm:fox-xpath-boolean" use="optional"/>
    <xs:attribute name="showWidget" type="fm:fox-xpath-boolean" use="optional"/>
    <xs:attribute name="showError" type="fm:fox-xpath-boolean" use="optional"/>
    <xs:attribute name="showHint" type="fm:fox-xpath-boolean" use="optional"/>
    <xs:attribute name="showDescription" type="fm:fox-xpath-boolean" use="optional"/>
    <xs:attributeGroup ref="fox:zzz-set-out-attr-grp"/>
    <xs:anyAttribute namespace="##other" processContents="skip"/>
  </xs:complexType>
  <xs:complexType name="menu-out-type" mixed="true">
    <xs:attributeGroup ref="fox:zzz-set-menu-attr-group"/>
    <xs:attribute name="action-context" type="fm:fox-xpath-type" use="optional">
      <xs:annotation>
        <xs:documentation>Sets :{action} to the node specified by this XPath</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:anyAttribute namespace="##other" processContents="skip"/>
  </xs:complexType>
  <xs:complexType name="header-footer-type">
    <xs:complexContent>
      <xs:extension base="html-or-fox-html-tags-type">
        <xs:attribute name="class" type="fm:fox-xpath-type" use="optional"/>
        <xs:attribute name="style" type="fm:fox-xpath-type" use="optional"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="page-number-type" mixed="true">
    <xs:complexContent>
      <xs:extension base="html-or-fox-html-tags-type">
        <xs:attribute name="class" type="fm:fox-xpath-type" use="optional"/>
        <xs:attribute name="style" type="fm:fox-xpath-type" use="optional"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:group name="using-clause-grp">
    <xs:sequence>
      <xs:element name="using" minOccurs="0" maxOccurs="unbounded">
        <xs:complexType>
          <xs:simpleContent>
            <xs:extension base="xs:string">
              <xs:attribute name="using-type" use="optional">
                <xs:simpleType>
                  <xs:restriction base="fm:entered-string">
                    <xs:enumeration value="XPATH"/>
                    <xs:enumeration value="UNIQUE"/>
                    <xs:enumeration value="STATIC"/>
                    <xs:enumeration value="DATA-XMLTYPE"/>
                    <xs:enumeration value="DATA-CLOB"/>
                    <xs:enumeration value="DATA-BLOB"/>
                    <xs:enumeration value="FILE-METADATA-XMLTYPE"/>
                  </xs:restriction>
                </xs:simpleType>
              </xs:attribute>
            </xs:extension>
          </xs:simpleContent>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:group>
  <xs:group name="validate-cmd-grp">
    <xs:sequence>
      <xs:element name="validate" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Validates data against schema, optionally creates missing nodes. Adds
            "error" nodes in context, or on summary target.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="match" type="fm:fox-xpath-type" use="optional">
            <xs:annotation>
              <xs:documentation>Identifies nodes to validate, defaults to current attach
                point.</xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="check" use="optional">
            <xs:annotation>
              <xs:documentation>This is a list of what should be checked during validation.
                Validation can be applied several times on the same data, each time with different
                things being checked. To keep error messages from previous validate calls, use the
                "clear" attribute. The default is ALL.</xs:documentation>
            </xs:annotation>
            <xs:simpleType>
              <xs:restriction base="fm:entered-string">
                <xs:enumeration value="ALL">
                  <xs:annotation>
                    <xs:documentation>Validate number of node occurences within parent , validate
                      immediate data content and nested nodes (depending on deep
                      attribute).</xs:documentation>
                  </xs:annotation>
                </xs:enumeration>
                <xs:enumeration value="CONTENT">
                  <xs:annotation>
                    <xs:documentation>Validate immediate data value, eg. validate-xpath,
                      enumerations, map-sets, etc.</xs:documentation>
                  </xs:annotation>
                </xs:enumeration>
                <xs:enumeration value="CARDINALITY">
                  <xs:annotation>
                    <xs:documentation>Validate number of sibling nodes (including matched node) with
                      a common name against schema minOccurs and MaxOccurs.</xs:documentation>
                  </xs:annotation>
                </xs:enumeration>
                <xs:enumeration value="NONE">
                  <xs:annotation>
                    <xs:documentation>Perform no validation. This can be used in conjunction with
                      "clear" or "init" attributes to initialise validation element
                      structures.</xs:documentation>
                  </xs:annotation>
                </xs:enumeration>
              </xs:restriction>
            </xs:simpleType>
          </xs:attribute>
          <xs:attribute name="init" type="fm:yn-flag" use="optional">
            <xs:annotation>
              <xs:documentation>Y indicates missing elements may be created in order to add
                contextual error messages. The default is Y. When used in conjunction with
                check="NONE", elements are created according to cardinality rules, but no error
                messages are created, thus initialising slots for input.</xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="clear" use="optional">
            <xs:annotation>
              <xs:documentation>Identifies previous error messages to remove from matched nodes,
                before validation begins, thus removing previous error messages. If errors are not
                removed first, multiple error nodes are created (which may be valid, or duplicates
                in error). Default is NONE.</xs:documentation>
            </xs:annotation>
            <xs:simpleType>
              <xs:restriction base="fm:entered-string">
                <xs:enumeration value="BOTH"/>
                <xs:enumeration value="CLEAR-NODE"/>
                <xs:enumeration value="CLEAR-SUMMARY"/>
                <xs:enumeration value="NONE"/>
              </xs:restriction>
            </xs:simpleType>
          </xs:attribute>
          <xs:attribute name="summary-target" type="fm:fox-xpath-type" use="optional">
            <xs:annotation>
              <xs:documentation>Locates a node which is used to add summary error message nodes to.
                Many node contextual errors will result in at least one summary error node being
                created also. Any one node contextual error must always create one summary error
                node, so that "boolean(mypath/summary/error)" returns true if any contextual errors
                were identified. The default summary-target is evaluated from XPATH expression
                "/*/error-list". An example target might be
                "../../section-one/issues".</xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="error-limit" type="xs:integer" use="optional">
            <xs:annotation>
              <xs:documentation>Error processing will stop when this number of errors is reached.
                This number includesa any previous uncleared error and works on the whole module not
                just the current page</xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="use-when-conditions" type="fm:fox-xpath-type" use="optional">
            <xs:annotation>
              <xs:documentation>Indicates whether to evaluate the validate-when condition on matched elements.</xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:group>
  <xs:group name="cmd-remove-grp">
    <xs:sequence>
      <xs:element name="remove" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Command to remove elements from data tree [USE WITH CAUTION] The match
            attribute must be specified and the builder should provide hard XPATH expressions to
            prevent accidental data loss. For example BAD PRACTICE: "./*" GOOD PRACTICE:
            "./(cat|dog|mouse)"</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="match" type="fm:fox-xpath-type" use="required">
            <xs:annotation>
              <xs:documentation>XPath expression to target elements to remove. This must be
                specified and the builder should provide hard XPATH expressions to prevent
                accidental data loss. For example BAD PRACTICE: "./*" GOOD PRACTICE:
                "./(cat|dog|mouse)". Empty xpath is not allowed. </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:group>
  <xs:group name="cmd-pragma-grp">
    <xs:sequence>
      <xs:element name="pragma" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Multifunctional pragmatic command to access and interact with Fox Servlet internals.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="function" use="required">
            <xs:annotation>
              <xs:documentation>Which pragma function to perform.</xs:documentation>
            </xs:annotation>
            <xs:simpleType>
              <xs:restriction base="fm:entered-string">
                <xs:enumeration value="hibernate-thread"/>
                <xs:enumeration value="set-html-response"/>
                <xs:enumeration value="set-xml-response"/>
              </xs:restriction>
            </xs:simpleType>
          </xs:attribute>
          <xs:attribute name="target" type="fm:fox-xpath-type" use="optional">
            <xs:annotation>
              <xs:documentation>Target element containing content to serve as XML or HTML response.</xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="response-mime-type" type="fm:entered-string" use="optional">
            <xs:annotation>
              <xs:documentation>Response MIME type for XML response.</xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="resume-action" type="fm:entered-string" use="optional">
            <xs:annotation>
              <xs:documentation>Action to run when resuming a hibernated thread.</xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="html-response-doctype" use="optional" default="HTML5">
            <xs:annotation>
              <xs:documentation>When using function=set-html-response the doctype will let you specify HTML5 style output (Default) or the legacy XHTML style output that returns raw XML content from the DOM like XHTML</xs:documentation>
            </xs:annotation>
            <xs:simpleType>
              <xs:restriction base="fm:entered-string">
                <xs:enumeration value="HTML5"/>
                <xs:enumeration value="XHTML"/>
              </xs:restriction>
            </xs:simpleType>
          </xs:attribute>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:group>
  <xs:group name="cmd-call-grp">
    <xs:annotation>
      <xs:documentation>Call an action.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="call" minOccurs="0">
        <xs:complexType>
          <xs:sequence minOccurs="0">
            <xs:element maxOccurs="unbounded" minOccurs="0" name="context">
              <xs:complexType>
                <xs:attribute name="name" type="fm:entered-string" use="required"/>
                <xs:attribute name="xpath" type="fm:entered-string" use="required"/>
              </xs:complexType>
            </xs:element>
            <xs:element maxOccurs="unbounded" minOccurs="0" name="variable">
              <xs:complexType>
                <xs:attribute name="name" type="fm:entered-string" use="required"/>
                <xs:attribute name="textValue" type="fm:entered-string"/>
                <xs:attribute name="expr" type="fm:entered-string"/>
              </xs:complexType>
            </xs:element>
          </xs:sequence>
          <xs:attribute name="action" type="fm:entered-string" use="required"/>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:group>
  <xs:simpleType name="slashless-entered-string">
    <xs:restriction base="fm:entered-string">
      <xs:pattern value="[^/]*"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="hours-minutes">
    <xs:restriction base="xs:string">
      <xs:pattern value="\d*:?\d+"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:complexType name="display-attr-list-type">
    <xs:sequence minOccurs="0">
      <xs:element name="attr" minOccurs="0" maxOccurs="unbounded">
        <xs:complexType>
          <xs:simpleContent>
            <xs:extension base="xs:string">
              <xs:attribute name="name" type="xs:string" use="required"/>
            </xs:extension>
          </xs:simpleContent>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:complexType>
  <xs:attributeGroup name="entry-theme-param-att-grp">
    <xs:attribute name="name" type="fm:entered-string" use="optional"/>
    <xs:attribute name="type" type="fm:entered-string" use="optional"/>
    <xs:attribute name="xpath" type="fm:fox-xpath-type" use="optional"/>
    <xs:attribute name="mand" use="optional">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="."/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="description" type="xs:string" use="optional"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="security-rule-conditions-att-grp">
    <xs:attribute name="privilege" type="xs:string"/>
    <xs:attribute name="theme" type="xs:string"/>
    <xs:attribute name="state" type="xs:string"/>
    <xs:attribute name="xpath" type="fm:fox-xpath-type"/>
    <xs:attribute name="datum-rec-path" type="fm:fox-xpath-type"/>
    <xs:attribute name="datum-type" type="xs:string"/>
    <xs:attribute name="datum-id" type="fm:fox-xpath-type"/>
    <xs:attribute name="datum-scope">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="EACH"/>
          <xs:enumeration value="ALL"/>
          <xs:enumeration value="ANY"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="build-only" type="xs:boolean"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="security-rule-op-att-grp">
    <xs:attribute name="namespace" type="fm:entered-string" use="optional">
      <xs:annotation>
        <xs:documentation>One or more namespaces, comma separated, that should be enabled or disabled by this rule.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namespace-groups" type="fm:entered-string" use="optional">
      <xs:annotation>
        <xs:documentation>One or more namespace groups, comma separated, that should be enabled or disabled by this rule.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="operation" use="required">
      <xs:simpleType>
        <xs:restriction base="fm:entered-string">
          <xs:enumeration value="ENABLE"/>
          <xs:enumeration value="DISABLE"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="security-rule-ref-att-grp">
    <xs:attribute name="rule-ref" type="xs:string" use="optional"/>
  </xs:attributeGroup>
  <xs:group name="server-side-include-cmd-grp">
    <xs:annotation>
      <xs:documentation>A group of server side include commands.</xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:element name="show-popup">
        <xs:annotation>
          <xs:documentation>A storage location or URI based server-side-include and client popup
            command. A resource retrieved is sent back to the client as a popup.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="window-name" type="fm:entered-string" use="optional">
            <xs:annotation>
              <xs:documentation>The browser client window name. If not specified, will default to a
                unique name that is automatically generated for each new window.</xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="js-win-features" type="xs:string" use="optional">
            <xs:annotation>
              <xs:documentation>The javascript window properties. For example:
                menubar=no,resizable=no,scrollbars=no,status=no,toolbar=no,width=600,height=400</xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="serve-as-attachment" type="fm:fox-xpath-type" use="optional">
            <xs:annotation>
              <xs:documentation>Xpath evaluating to true will cause payload to be served as an attachment.</xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="serve-as-response" type="fm:fox-xpath-type" use="optional">
            <xs:annotation>
              <xs:documentation>Xpath evaluating to true will cause payload to be served as the HTTP response, bypassing normal HTML generation.</xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attributeGroup ref="fm:storage-location-popup-resource-att-grp"/>
          <xs:attributeGroup ref="fm:url-based-popup-resource-att-grp"/>
          <xs:attributeGroup ref="fm:doc-template-popup-att-grp"/>
          <xs:attributeGroup ref="fm:matrix-record-popup-att-grp"/>
          <xs:attributeGroup ref="fm:zip-file-popup-att-grp"/>
          <xs:attributeGroup ref="fm:db-based-popup-resource-att-grp"/>
        </xs:complexType>
      </xs:element>
    </xs:choice>
  </xs:group>
  <xs:attributeGroup name="storage-location-popup-resource-att-grp">
    <xs:annotation>
      <xs:documentation>A storage-location based server-side-include popup resource attribute
        group.</xs:documentation>
    </xs:annotation>
    <xs:attribute name="storage-location" type="fm:entered-string" use="optional">
      <xs:annotation>
        <xs:documentation>The storage location of the LOB or XMLType whose content is to be
          retrieved on the server and displayed in a popup on the client.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="file-name" type="fm:entered-string" use="optional">
      <xs:annotation>
        <xs:documentation>The filename of the browser popup resource. This might be "mydoc.pdf" to
          force the browser to consider the real resource type to be PDF and to facilitate
          recognisible file names to a user that might want to "Save As..." the resource. This might
          also prove useful if the content type is not retrieved by the URI or storage location
          query and the type is implied from this name.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="url-based-popup-resource-att-grp">
    <xs:annotation>
      <xs:documentation>A URI based server-side-include popup resource attribute
        group.</xs:documentation>
    </xs:annotation>
    <xs:attribute name="uri" type="fm:entered-string" use="optional"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="db-based-popup-resource-att-grp">
    <xs:annotation>
      <xs:documentation>A group of attributes to get popup resources from a query (Currently for use
        when zipping)</xs:documentation>
    </xs:annotation>
    <xs:attribute name="db-interface" type="fm:entered-string" use="optional"/>
    <xs:attribute name="db-query" type="fm:entered-string" use="optional"/>
    <xs:attribute name="db-match" type="fm:fox-xpath-type" use="optional"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="doc-template-popup-att-grp">
    <xs:annotation>
      <xs:documentation>A group of attributes used by show-popup to preview generated documents a
        template.</xs:documentation>
    </xs:annotation>
    <xs:attribute name="doc-template-name" type="fm:entered-string" use="optional"/>
    <xs:attribute name="doc-template-target-metadata" type="fm:fox-xpath-type" use="optional"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="matrix-record-popup-att-grp">
    <xs:annotation>
      <xs:documentation>An group of attributes for launching a popup that displays a record in
        MATRIX.</xs:documentation>
    </xs:annotation>
    <xs:attribute name="matrix-record-no-xpath" type="fm:fox-xpath-type" use="optional"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="zip-file-popup-att-grp">
    <xs:annotation>
      <xs:documentation>A group of attributes for launching a popup that generates and returns a zip
        file</xs:documentation>
    </xs:annotation>
    <xs:attribute name="zip-archive-name" type="fm:entered-string" use="optional"/>
    <xs:attribute name="zip-compression-level" type="fm:entered-string" use="optional" default="0"/>
  </xs:attributeGroup>
  <xs:group name="generate-cmd-grp">
    <xs:annotation>
      <xs:documentation>Generate command group.</xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:element name="generate-sheet" minOccurs="0" maxOccurs="unbounded">
        <xs:annotation>
          <xs:documentation>Creates an associated Excel worksheet in the output
            document.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="generate-column" maxOccurs="unbounded">
              <xs:annotation>
                <xs:documentation>Represents a column of data in the worksheet. The column
                  specification includes an expression to populate the column
                  cells.</xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:attribute name="name" type="xs:string" use="optional"/>
                <xs:attribute name="column-expr" type="fm:fox-xpath-type" use="required"/>
                <xs:attribute name="visible-expr" type="fm:fox-xpath-type" use="optional" default="true">
                  <xs:annotation>
                    <xs:documentation>An XPath expression which determines whether the specified
                      column will be output (visible) in the generated content. The XPath expression
                      must therefore return a valid XPath boolean result. Defaults to
                      true.</xs:documentation>
                  </xs:annotation>
                </xs:attribute>
                <xs:attributeGroup ref="fm:data-type-att-grp"/>
              </xs:complexType>
            </xs:element>
          </xs:sequence>
          <xs:attribute name="name" type="xs:string" use="optional">
            <xs:annotation>
              <xs:documentation>The name of the worksheet to create. This may be specified as a
                simple string, such as name="sheet1", or as an XPATH expression, {expr}, that would
                yield a simple string value, specified as "string({expr})". Any XPATH expression is
                computed relative to the current attachment point. For example, name="Hello World!"
                and name="string('Hello World!')" are identical. Other examples include: 1)
                name="string(/*/EMP_LIST/EMP/@name)" 2) name="string(./DEPARTMENT[0]/@name)" 3)
                name="string(concat('Sheet #', count(preceding-sibling::EMP)+1))" would yield
                worksheet names (per employee in this case) like "Sheet #1", "Sheet #2" ... "Sheet
                #n" </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="row-expr" type="xs:string" use="required"/>
          <xs:attribute name="show-headers" type="xs:string" use="optional"/>
        </xs:complexType>
      </xs:element>
    </xs:choice>
  </xs:group>
  <xs:group name="parse-spreadsheet-cmd-grp">
    <xs:choice>
      <xs:element name="worksheet-list">
        <xs:complexType>
          <xs:sequence>
            <xs:element name="worksheet" minOccurs="0" maxOccurs="unbounded">
              <xs:complexType>
                <xs:attribute name="name" type="fm:entered-string" use="required"/>
              </xs:complexType>
            </xs:element>
          </xs:sequence>
          <xs:attribute name="mode" use="optional" default="include">
            <xs:simpleType>
              <xs:restriction base="fm:entered-string">
                <xs:enumeration value="include"/>
                <xs:enumeration value="exclude"/>
              </xs:restriction>
            </xs:simpleType>
          </xs:attribute>
        </xs:complexType>
      </xs:element>
    </xs:choice>
  </xs:group>
  <xs:attributeGroup name="data-type-att-grp">
    <xs:annotation>
      <xs:documentation>A group of attributes that defines the type and format specification of a
        data element.</xs:documentation>
    </xs:annotation>
    <xs:attribute name="datatype" use="optional" default="auto">
      <xs:annotation>
        <xs:documentation>The required type of the element. Refer to the 'enumerations' for the list
          of values accepted for the type attribute. Also, if the type is "real" or "integer" you
          may supply a format specification mask for the resulting string representation in the
          output, using the output-format attribute. The format-spec attribute uses the Java
          DecimalFormat and SimpleDateFormat fomat models for numbers and dates respectively. These
          are available at http://java.sun.com/j2se/1.4.2/docs/api/java/text/DecimalFormat.html and
          http://java.sun.com/j2se/1.4.2/docs/api/java/text/SimpleDateFormat.html
          respectively.</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="string"/>
          <xs:enumeration value="integer"/>
          <xs:enumeration value="real"/>
          <xs:enumeration value="boolean"/>
          <xs:enumeration value="date"/>
          <xs:enumeration value="time"/>
          <xs:enumeration value="datetime"/>
          <xs:enumeration value="auto"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="input-format" type="xs:string" use="optional">
      <xs:annotation>
        <xs:documentation>The accepted format patterns for the type specified, if parsing as input
          from a string. Only used when the specified type is "integer" or "real". The accepted
          input-format patterns are the Java DecimalFormat and SimpleDateFormat fomat models for
          numbers and dates, respectively. These are available at
          http://java.sun.com/j2se/1.4.2/docs/api/java/text/DecimalFormat.html and
          http://java.sun.com/j2se/1.4.2/docs/api/java/text/SimpleDateFormat.html respectively.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="output-format" type="xs:string" use="optional">
      <xs:annotation>
        <xs:documentation>The accepted format patterns for the type specified. Only used when the
          specified type is "integer" or "real". The format-spec attribute usage differs for the
          cases where method is CSV and XLS. When method is CSV the Java DecimalFormat and
          SimpleDateFormat fomat models for numbers and dates, respectively, are used. These are
          available at http://java.sun.com/j2se/1.4.2/docs/api/java/text/DecimalFormat.html and
          http://java.sun.com/j2se/1.4.2/docs/api/java/text/SimpleDateFormat.html respectively. The
          default format specification for integers is "#" (any number of digits); the default for
          reals is "0.00" (2 decimal places with zeros always present, rounded if necessary). When
          the method is XLS then one of the Excel built-in format model listed below must be used:
          General 0 0.00 #,##0 #,##0.00 ($#,##0_);($#,##0) ($#,##0_);[Red]($#,##0)
          ($#,##0.00);($#,##0.00) ($#,##0.00_);[Red]($#,##0.00) 0% 0.00% 0.00E+00 # ?/? # ??/??
          m/d/yy d-mmm-yy d-mmm mmm-yy h:mm AM/PM h:mm:ss AM/PM h:mm h:mm:ss m/d/yy h:mm
          (#,##0_);[Red](#,##0) (#,##0.00_);(#,##0.00) (#,##0.00_);[Red](#,##0.00)
          _(*#,##0_);_(*(#,##0);_(* \"-\"_);_(@_) _($*#,##0_);_($*(#,##0);_($* \"-\"_);_(@_)
          _(*#,##0.00_);_(*(#,##0.00);_(*\"-\"??_);_(@_)
          _($*#,##0.00_);_($*(#,##0.00);_($*\"-\"??_);_(@_) mm:ss [h]:mm:ss mm:ss.0 ##0.0E+0 @ text
          - Alias for @ </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="case-attr-grp">
    <xs:attribute name="expr" type="fm:fox-xpath-type" use="optional">
      <xs:annotation>
        <xs:documentation>An XPath which returns a single value. Mutually exclusive with "value".</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="value" type="fm:entered-string" use="optional">
      <xs:annotation>
        <xs:documentation>A single string value. Mutually exclusive with "expr".</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:complexType name="documentation">
    <xs:sequence>
      <xs:element name="description">
        <xs:annotation>
          <xs:documentation>Description of the main purpose or usage</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="comments">
        <xs:annotation>
          <xs:documentation>Any other comments usefull for other developers</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="pre-condition" minOccurs="0" maxOccurs="unbounded">
        <xs:annotation>
          <xs:documentation>Any parameters, contexts, or data required before use</xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="client-visibility-rule-condition-type">
    <xs:choice minOccurs="1" maxOccurs="1">
      <xs:element name="and" type="fm:client-visibility-rule-boolean-condition-type"/>
      <xs:element name="or" type="fm:client-visibility-rule-boolean-condition-type"/>
      <xs:group ref="fm:client-visibility-rule-condition-grp"/>
    </xs:choice>
  </xs:complexType>
  <xs:complexType name="client-visibility-rule-boolean-condition-type">
    <xs:choice minOccurs="2" maxOccurs="unbounded">
      <xs:element name="and" type="fm:client-visibility-rule-boolean-condition-type"/>
      <xs:element name="or" type="fm:client-visibility-rule-boolean-condition-type"/>
      <xs:group ref="fm:client-visibility-rule-condition-grp"/>
    </xs:choice>
  </xs:complexType>
  <xs:group name="client-visibility-rule-condition-grp">
    <xs:choice>
      <xs:element name="widget">
        <xs:complexType>
          <xs:attribute name="target" type="fm:entered-string" use="optional"/>
          <xs:attribute name="use-target-from-schema" type="xs:string" use="optional" fixed="yes"/>
          <xs:attribute name="condition-type" use="required">
            <xs:annotation>
              <xs:documentation/>
            </xs:annotation>
            <xs:simpleType>
              <xs:restriction base="xs:string">
                <xs:enumeration value="equals"/>
                <xs:enumeration value="not-equals"/>
                <xs:enumeration value="null"/>
                <xs:enumeration value="not-null"/>
              </xs:restriction>
            </xs:simpleType>
          </xs:attribute>
          <xs:attribute name="value" type="fm:fox-xpath-type" use="optional"/>
          <xs:attribute name="use-value-from-schema" type="xs:string" use="optional" fixed="yes"/>
        </xs:complexType>
      </xs:element>
      <xs:element name="fixed-xpath">
        <xs:complexType>
          <xs:attribute name="test" type="fm:fox-xpath-type" use="required"/>
        </xs:complexType>
      </xs:element>
      <xs:element name="nested-rule">
        <xs:complexType>
          <xs:attribute name="name" type="fm:entered-string" use="required"/>
        </xs:complexType>
      </xs:element>
    </xs:choice>
  </xs:group>
  <xs:attributeGroup name="mapset-interface-query-attr-grp">
    <xs:attribute name="interface" type="fm:entered-string" use="required">
      <xs:annotation>
        <xs:documentation>Name of database interface containing mapset query.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="query" type="fm:entered-string" use="required">
      <xs:annotation>
        <xs:documentation>Name of mapset query within the db-interface.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="match" type="fm:entered-string" use="optional">
      <xs:annotation>
        <xs:documentation>Optional match attribute for the query to control the relative node for any query bind variables containing relative paths. If not specified, the default match point is the current state attach point.

          If you specify a match attribute you will need to define an explicit cache key because the cache key is always evaluated from the state attach point, never from the query match point. </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="sl-option-attr-grp">
    <xs:attribute name="synchronisation-mode">
      <xs:annotation>
        <xs:documentation>Defines how database storage location updates are handled. The default is 'synchronised' if not specified.</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="synchronised"/>
          <xs:enumeration value="unsynchronised"/>
          <xs:enumeration value="read-only"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="validation-enabled">
      <xs:annotation>
        <xs:documentation>Controls if the fm:validation section of the storage location definition should be executed within this entry theme, if it is defined. The default is 'true'. Note this setting only applies to synchronised storage locations.</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:restriction base="xs:boolean"/>
      </xs:simpleType>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:complexType name="page-control-button-config">
    <xs:attribute name="enabled" type="xs:boolean"/>
    <xs:attribute name="label"/>
  </xs:complexType>
  <xs:complexType name="tab-base-type">
    <xs:sequence>
      <xs:element name="tab-prompt">
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="html-or-fox-html-tags-type">
              <xs:attribute name="text" type="fm:entered-string"/>
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="tab-content">
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="html-or-fox-html-tags-type"/>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
    <xs:attribute name="preTabChangeAction" type="fm:entered-string"/>
    <xs:attribute name="postTabChangeAction" type="fm:entered-string"/>
    <xs:attribute name="visible" type="fm:entered-string">
      <xs:annotation>
        <xs:documentation>XPath boolean. If true, this tab will be visible on the screen. Default is true if not specified.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="enabled" type="fm:entered-string"/>
    <xs:attribute name="displayOrder" type="fm:entered-string"/>
    <xs:attribute name="default" type="fm:entered-string">
      <xs:annotation>
        <xs:documentation>XPath boolean. If true, this tab will be the initially selected tab when the tab group is first displayed.
          If not specified, a value of "false()" is assumed.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="tab-type">
    <xs:complexContent>
      <xs:extension base="fm:tab-base-type">
        <xs:attribute name="tabKey" type="fm:entered-string" use="required"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="tab-for-each-dom-type">
    <xs:complexContent>
      <xs:extension base="fm:tab-base-type">
        <xs:attribute name="xpath" type="fm:entered-string"/>
        <xs:attribute name="tabContextName" type="fm:entered-string" use="optional" default="tab"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="tab-for-each-number-type">
    <xs:complexContent>
      <xs:extension base="fm:tab-base-type">
        <xs:attribute name="from" type="fm:entered-string"/>
        <xs:attribute name="to" type="fm:entered-string"/>
        <xs:attribute name="tabKey" type="fm:entered-string"/>
        <xs:attribute name="tabContextName" type="fm:entered-string" use="optional" default="tab"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
</xs:schema>
